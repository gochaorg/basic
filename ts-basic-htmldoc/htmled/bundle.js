/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./out/hello.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/ts-basic-core/ast/AstToBasic.js":
/*!******************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/AstToBasic.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst OperatorExp_1 = __webpack_require__(/*! ./OperatorExp */ \"./node_modules/ts-basic-core/ast/OperatorExp.js\");\nconst LetStatement_1 = __webpack_require__(/*! ./LetStatement */ \"./node_modules/ts-basic-core/ast/LetStatement.js\");\nconst RemStatement_1 = __webpack_require__(/*! ./RemStatement */ \"./node_modules/ts-basic-core/ast/RemStatement.js\");\nconst RunStatement_1 = __webpack_require__(/*! ./RunStatement */ \"./node_modules/ts-basic-core/ast/RunStatement.js\");\nconst Statements_1 = __webpack_require__(/*! ./Statements */ \"./node_modules/ts-basic-core/ast/Statements.js\");\nconst SourceUnit_1 = __webpack_require__(/*! ../vm/SourceUnit */ \"./node_modules/ts-basic-core/vm/SourceUnit.js\");\nconst GotoStatement_1 = __webpack_require__(/*! ./GotoStatement */ \"./node_modules/ts-basic-core/ast/GotoStatement.js\");\nconst IfStatement_1 = __webpack_require__(/*! ./IfStatement */ \"./node_modules/ts-basic-core/ast/IfStatement.js\");\nconst GoSubStatement_1 = __webpack_require__(/*! ./GoSubStatement */ \"./node_modules/ts-basic-core/ast/GoSubStatement.js\");\nconst ReturnStatement_1 = __webpack_require__(/*! ./ReturnStatement */ \"./node_modules/ts-basic-core/ast/ReturnStatement.js\");\nconst PrintStatement_1 = __webpack_require__(/*! ./PrintStatement */ \"./node_modules/ts-basic-core/ast/PrintStatement.js\");\nconst CallStatement_1 = __webpack_require__(/*! ./CallStatement */ \"./node_modules/ts-basic-core/ast/CallStatement.js\");\n/**\n * Генератор из AST в BASIC\n */\nfunction astToBasic(root, opts) {\n    if (opts == undefined) {\n        opts = {\n            sourceLineNumber: true\n        };\n    }\n    if (root == undefined)\n        return \"\";\n    if (root == null)\n        return \"\";\n    //#region LiteralExpression\n    if (root instanceof OperatorExp_1.LiteralExpression) {\n        if (typeof (root.value) == 'number') {\n            return '' + root.value;\n        }\n        else if (typeof (root.value) == 'boolean') {\n            if (root.value) {\n                return '1<2';\n            }\n            else {\n                return '1>2';\n            }\n        }\n        else if (typeof (root.value) == 'string') {\n            const sval = root.value;\n            let str = \"\\\"\";\n            for (let i = 0; i < sval.length; i++) {\n                let ch = sval[i];\n                if (ch == '\"') {\n                    str += \"{encode_dquote}\";\n                }\n                else if (ch == \"'\") {\n                    str += \"{encode_quote}\";\n                }\n                else if (ch == \"\\n\") {\n                    str += \"{encode_nl}\";\n                }\n                else if (ch == \"\\r\") {\n                    str += \"{encode_cr}\";\n                }\n                else if (ch == \"\\t\") {\n                    str += \"{encode_tab}\";\n                }\n                else if (ch.charCodeAt(0) > 31) {\n                    str += ch;\n                }\n            }\n            str += \"\\\"\";\n            return str;\n        }\n        else {\n            throw new Error(`unknow Literal value type = ${typeof (root.value)}`);\n        }\n    }\n    //#endregion\n    //#region var ref\n    if (root instanceof OperatorExp_1.VarArrIndexRef) {\n        let code = '';\n        code += root.varname;\n        code += '(';\n        let idx = -1;\n        for (let aidx of root.indexes) {\n            idx++;\n            if (idx > 0)\n                code += ',';\n            code += astToBasic(aidx, opts);\n        }\n        code += ')';\n        return code;\n    }\n    //#endregion\n    //#region var ref\n    if (root instanceof OperatorExp_1.VarRefExpression) {\n        return root.varname;\n    }\n    //#endregion\n    //#region unary ref\n    if (root instanceof OperatorExp_1.UnaryOpExpression) {\n        return root.operator.keyWord + '(' + astToBasic(root.base, opts) + ')';\n    }\n    //#endregion\n    //#region BinaryOpExpression\n    if (root instanceof OperatorExp_1.BinaryOpExpression) {\n        let code = '';\n        if (root.left.treeSize > 1) {\n            code += '(' + astToBasic(root.left, opts) + ')';\n        }\n        else {\n            code += astToBasic(root.left, opts);\n        }\n        code += root.operator.keyWord;\n        if (root.right.treeSize > 1) {\n            code += '(' + astToBasic(root.right, opts) + ')';\n        }\n        else {\n            code += astToBasic(root.right, opts);\n        }\n        return code;\n    }\n    //#endregion\n    //#region LET\n    if (root instanceof LetStatement_1.LetStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += `LET ${root.varname} = ${astToBasic(root.value, opts)}`;\n        return code;\n    }\n    //#endregion\n    //#region REM\n    if (root instanceof RemStatement_1.RemStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += `REM ${root.rem.comment}`;\n        return code;\n    }\n    //#endregion\n    //#region RUN\n    if (root instanceof RunStatement_1.RunStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"RUN\";\n        if (root.runLine != undefined) {\n            code += ` ${root.runLine}`;\n        }\n        return code;\n    }\n    //#endregion\n    //#region GOTO\n    if (root instanceof GotoStatement_1.GotoStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"GOTO\";\n        if (root.gotoLine != undefined) {\n            code += ` ${root.gotoLine.value}`;\n        }\n        return code;\n    }\n    //#endregion\n    //#region GOSUB\n    if (root instanceof GoSubStatement_1.GoSubStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"GOSUB\";\n        if (root.gotoLine != undefined) {\n            code += ` ${root.gotoLine.value}`;\n        }\n        return code;\n    }\n    //#endregion\n    //#region RETURN\n    if (root instanceof ReturnStatement_1.ReturnStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"RETURN\";\n        if (root.gotoLine != undefined) {\n            code += ` ${root.gotoLine.value}`;\n        }\n        return code;\n    }\n    //#endregion\n    //#region IF\n    if (root instanceof IfStatement_1.IfStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"IF \";\n        code += astToBasic(root.boolExp, opts);\n        code += \" THEN \";\n        code += astToBasic(root.trueStatement, { sourceLineNumber: false });\n        if (root.falseStatement) {\n            code += \" ELSE \";\n            code += astToBasic(root.falseStatement, { sourceLineNumber: false });\n        }\n        return code;\n    }\n    //#endregion\n    //#region PrintStatement\n    if (root instanceof PrintStatement_1.PrintStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"PRINT\";\n        if (root.args.length > 0)\n            code += \" \";\n        let argi = -1;\n        root.args.forEach(arg => {\n            argi++;\n            if (argi > 0) {\n                code += \",\";\n            }\n            code += astToBasic(arg, opts);\n        });\n        return code;\n    }\n    //#endregion\n    //#region CallStatement\n    if (root instanceof CallStatement_1.CallStatement) {\n        let code = '';\n        if (root.sourceLine != undefined && opts.sourceLineNumber) {\n            code = `${root.sourceLine} `;\n        }\n        code += \"CALL \";\n        code += root.name.id;\n        if (root.args.length > 0)\n            code += \" \";\n        let argi = -1;\n        root.args.forEach(arg => {\n            argi++;\n            if (argi > 0) {\n                code += \",\";\n            }\n            code += astToBasic(arg, opts);\n        });\n        return code;\n    }\n    //#endregion\n    //#region Statements\n    if (root instanceof Statements_1.Statements) {\n        let code = '';\n        root.statements.forEach(st => {\n            if (code.length > 0) {\n                code += \"\\n\";\n            }\n            code += astToBasic(st, opts);\n        });\n        return code;\n    }\n    //#endregion\n    //#region SourceUnit\n    if (root instanceof SourceUnit_1.SourceUnit) {\n        let code = '';\n        root.lines.forEach(line => {\n            if (code.length > 0) {\n                code += \"\\n\";\n            }\n            code += astToBasic(line.statement, opts);\n        });\n        return code;\n    }\n    //#endregion\n    throw new Error(\"unknow argument type \" + root + \":\" + Object.getPrototypeOf(root));\n}\nexports.astToBasic = astToBasic;\n//# sourceMappingURL=AstToBasic.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/AstToBasic.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/CallStatement.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/CallStatement.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass CallStatement extends Statement_1.Statement {\n    constructor(begin, end, call, name, args) {\n        super();\n        this.kind = 'Call';\n        this.begin = begin;\n        this.end = end;\n        this.call = call;\n        this.name = name;\n        this.args = args;\n    }\n}\nexports.CallStatement = CallStatement;\n//# sourceMappingURL=CallStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/CallStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/GoSubStatement.js":
/*!**********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/GoSubStatement.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass GoSubStatement extends Statement_1.Statement {\n    constructor(begin, end, line) {\n        super();\n        this.kind = 'Gosub';\n        this.begin = begin;\n        this.end = end;\n        this.gotoLine = line;\n    }\n}\nexports.GoSubStatement = GoSubStatement;\n//# sourceMappingURL=GoSubStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/GoSubStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/GotoStatement.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/GotoStatement.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass GotoStatement extends Statement_1.Statement {\n    constructor(begin, end, line) {\n        super();\n        this.kind = 'Goto';\n        this.begin = begin;\n        this.end = end;\n        this.gotoLine = line;\n    }\n}\nexports.GotoStatement = GotoStatement;\n//# sourceMappingURL=GotoStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/GotoStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/IfStatement.js":
/*!*******************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/IfStatement.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass IfStatement extends Statement_1.Statement {\n    constructor(begin, end, boolExp, trueStatement, falseStatement) {\n        super();\n        this.kind = 'If';\n        this.begin = begin;\n        this.end = end;\n        this.boolExp = boolExp;\n        this.trueStatement = trueStatement;\n        this.falseStatement = falseStatement;\n    }\n}\nexports.IfStatement = IfStatement;\n//# sourceMappingURL=IfStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/IfStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/LetStatement.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/LetStatement.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass LetStatement extends Statement_1.Statement {\n    constructor(begin, end, variable, value) {\n        super();\n        this.kind = 'Let';\n        this.begin = begin;\n        this.end = end;\n        this.variable = variable;\n        this.value = value;\n    }\n    get varname() { return this.variable.id; }\n}\nexports.LetStatement = LetStatement;\n//# sourceMappingURL=LetStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/LetStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/Lexer.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/Lexer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Работа с лексемами BASIC\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Абстрактная поддержка лексем\n */\nclass AbstractLex {\n    constructor(begin, end) {\n        if (begin !== undefined) {\n            this.begin = begin;\n        }\n        else {\n            this.begin = 0;\n        }\n        if (end !== undefined) {\n            this.end = end;\n        }\n        else {\n            this.end = 0;\n        }\n    }\n}\nexports.AbstractLex = AbstractLex;\n/**\n * Получение списка лексем из текста\n * @param text текст\n * @param lexs парсеры лексем\n */\nfunction lexems(text, lexs) {\n    let res = [];\n    let off = 0;\n    while (true) {\n        if (off >= text.length)\n            break;\n        let lx = null;\n        for (let lxParse of lexs) {\n            if (lx != null)\n                break;\n            lx = lxParse(text, off);\n            if (lx != null) {\n                if (lx.end <= off)\n                    throw new Error(\"fail lexem parse, end(=\" + lx.end + \") < off(=\" + off + \")\");\n                res.push(lx);\n                off = lx.end;\n                break;\n            }\n        }\n        if (lx == null)\n            throw new Error(\"can't parse \" + text.substring(off, off + 50));\n    }\n    return res;\n}\nexports.lexems = lexems;\n/**\n * Поддержка разных классов символов\n */\nclass Chars {\n    static isWS(str) {\n        if (str == ' ')\n            return true;\n        if (str == '\\n')\n            return true;\n        if (str == '\\r')\n            return true;\n        if (str == '\\t')\n            return true;\n        return false;\n    }\n    static isNewline(str) {\n        if (str == '\\n')\n            return true;\n        if (str == '\\r')\n            return true;\n        if (str == '\\n\\r')\n            return true;\n        if (str == '\\r\\n')\n            return true;\n        return false;\n    }\n    static isHexDigit(str) {\n        if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4')\n            return true;\n        if (str == '5' || str == '6' || str == '7' || str == '8' || str == '9')\n            return true;\n        if (str == 'A' || str == 'B' || str == 'C')\n            return true;\n        if (str == 'D' || str == 'E' || str == 'F')\n            return true;\n        if (str == 'a' || str == 'b' || str == 'c')\n            return true;\n        if (str == 'd' || str == 'e' || str == 'f')\n            return true;\n        return false;\n    }\n    static hexDigit(str) {\n        if (!Chars.isHexDigit(str))\n            throw new Error(\"not a digit\");\n        if (str == '0')\n            return 0;\n        if (str == '1')\n            return 1;\n        if (str == '2')\n            return 2;\n        if (str == '3')\n            return 3;\n        if (str == '4')\n            return 4;\n        if (str == '5')\n            return 5;\n        if (str == '6')\n            return 6;\n        if (str == '7')\n            return 7;\n        if (str == '8')\n            return 8;\n        if (str == '9')\n            return 9;\n        if (str == 'a' || str == 'A')\n            return 10;\n        if (str == 'b' || str == 'B')\n            return 11;\n        if (str == 'c' || str == 'C')\n            return 12;\n        if (str == 'd' || str == 'D')\n            return 13;\n        if (str == 'e' || str == 'E')\n            return 14;\n        if (str == 'f' || str == 'F')\n            return 15;\n        throw new Error(\"not a digit\");\n    }\n    static isDecDigit(str) {\n        if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4')\n            return true;\n        if (str == '5' || str == '6' || str == '7' || str == '8' || str == '9')\n            return true;\n        return false;\n    }\n    static decDigit(str) {\n        if (!Chars.isDecDigit(str))\n            throw new Error(\"not a digit\");\n        if (str == '0')\n            return 0;\n        if (str == '1')\n            return 1;\n        if (str == '2')\n            return 2;\n        if (str == '3')\n            return 3;\n        if (str == '4')\n            return 4;\n        if (str == '5')\n            return 5;\n        if (str == '6')\n            return 6;\n        if (str == '7')\n            return 7;\n        if (str == '8')\n            return 8;\n        if (str == '9')\n            return 9;\n        throw new Error(\"not a digit\");\n    }\n    static isOctDigit(str) {\n        if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4')\n            return true;\n        if (str == '5' || str == '6' || str == '7')\n            return true;\n        return false;\n    }\n    static octDigit(str) {\n        if (!Chars.isOctDigit(str))\n            throw new Error(\"not a digit\");\n        if (str == '0')\n            return 0;\n        if (str == '1')\n            return 1;\n        if (str == '2')\n            return 2;\n        if (str == '3')\n            return 3;\n        if (str == '4')\n            return 4;\n        if (str == '5')\n            return 5;\n        if (str == '6')\n            return 6;\n        if (str == '7')\n            return 7;\n        throw new Error(\"not a digit\");\n    }\n}\nexports.Chars = Chars;\n/**\n * Лексема пробельного текста\n */\nclass WhiteSpaceLex extends AbstractLex {\n    constructor(begin, end) {\n        super(begin, end);\n        this.kind = 'WhiteSpaceLex';\n    }\n    static parse(str, off) {\n        if (off >= str.length)\n            return null;\n        if (!Chars.isWS(str.substr(off, 1)))\n            return null;\n        let from = off;\n        while (true) {\n            if (off >= str.length)\n                break;\n            if (!Chars.isWS(str.substr(off, 1)))\n                break;\n            off++;\n        }\n        let to = off;\n        return new WhiteSpaceLex(from, to);\n    }\n}\nexports.WhiteSpaceLex = WhiteSpaceLex;\n/**\n * Лексема ключевых слов\n */\nclass KeyWordLex extends AbstractLex {\n    constructor(keyWord, begin, end) {\n        super(begin, end);\n        this.keyWord = keyWord;\n    }\n    // static defaultKeyWordBuilder : (kw:string, kwBegin:number, kwEnd:number)=>Lex = (kw,kwBegin,kwEnd) => {\n    //     return new KeyWordLex(kw, kwBegin, kwEnd)\n    // }\n    static parser(ignorecase, keyWords, keyWordBuilder) {\n        keyWords = keyWords.sort((a, b) => 0 - (a.length - b.length));\n        return (str, off) => {\n            if (off >= str.length)\n                return null;\n            for (let kw of keyWords) {\n                let ss = str.substring(off, off + kw.length);\n                if ((ignorecase && ss.toUpperCase() == kw.toUpperCase()) ||\n                    (!ignorecase && ss == kw)) {\n                    //return new KeyWordLex(ss,off,off+ss.length)\n                    if (keyWordBuilder) {\n                        return keyWordBuilder(ss, off, off + ss.length);\n                    }\n                    else {\n                        return new ParsedKeyWordLex(ss, off, off + ss.length);\n                    }\n                }\n            }\n            return null;\n        };\n    }\n}\nexports.KeyWordLex = KeyWordLex;\nclass ParsedKeyWordLex extends KeyWordLex {\n    constructor() {\n        super(...arguments);\n        this.kind = \"ParsedKeyWordLex\";\n    }\n}\nexports.ParsedKeyWordLex = ParsedKeyWordLex;\n/**\n * Лексема начала новой строки\n */\nclass NewLineLex extends KeyWordLex {\n    constructor(keyWord, begin, end) {\n        super(keyWord, begin, end);\n        this.kind = 'NewLineSeparator';\n    }\n}\nexports.NewLineLex = NewLineLex;\nNewLineLex.parse = KeyWordLex.parser(false, ['\\n\\r', '\\r\\n', '\\n', '\\r'], (kw, begin, end) => { return new NewLineLex(kw, begin, end); });\n/**\n * Лексема встроенного оператора\n */\nclass OperatorLex extends KeyWordLex {\n    constructor(keyWord, begin, end) {\n        super(keyWord, begin, end);\n        this.kind = 'OperatorLex';\n    }\n    get pow() { return this.keyWord != null && this.keyWord == '^'; }\n    get mult() { return this.keyWord != null && this.keyWord == '*'; }\n    get div() { return this.keyWord != null && this.keyWord == '/'; }\n    get idiv() { return this.keyWord != null && this.keyWord == '\\\\'; }\n    get mod() { return this.keyWord != null && this.keyWord.toUpperCase() == 'MOD'; }\n    get plus() { return this.keyWord != null && this.keyWord == '+'; }\n    get minus() { return this.keyWord != null && this.keyWord == '-'; }\n    get equals() { return this.keyWord != null && this.keyWord == '='; }\n    get notEquals() { return this.keyWord != null && (this.keyWord == '<>' || this.keyWord == '><'); }\n    get less() { return this.keyWord != null && this.keyWord == '<'; }\n    get lesOrEquals() { return this.keyWord != null && (this.keyWord == '<=' || this.keyWord == '=<'); }\n    get more() { return this.keyWord != null && this.keyWord == '>'; }\n    get moreOrEquals() { return this.keyWord != null && (this.keyWord == '>=' || this.keyWord == '=>'); }\n    get ordReleation() { return this.more || this.moreOrEquals || this.equals || this.notEquals || this.lesOrEquals || this.less; }\n    get not() { return this.keyWord != null && this.keyWord.toUpperCase() == 'NOT'; }\n    get and() { return this.keyWord != null && this.keyWord.toUpperCase() == 'AND'; }\n    get or() { return this.keyWord != null && this.keyWord.toUpperCase() == 'OR'; }\n    get xor() { return this.keyWord != null && this.keyWord.toUpperCase() == 'XOR'; }\n    get eqv() { return this.keyWord != null && this.keyWord.toUpperCase() == 'EQV'; }\n    get imp() { return this.keyWord != null && this.keyWord.toUpperCase() == 'IMP'; }\n    get arrBrOpen() { return this.keyWord != null && this.keyWord.toUpperCase() == '('; }\n    get arrBrClose() { return this.keyWord != null && this.keyWord.toUpperCase() == ')'; }\n    get argDelim() { return this.keyWord != null && this.keyWord.toUpperCase() == ','; }\n}\nexports.OperatorLex = OperatorLex;\nOperatorLex.parse = KeyWordLex.parser(true, [\n    '(', ')',\n    // математические операции в порядке уменьшения приоритета\n    '^',\n    '*', '/',\n    '\\\\',\n    'MOD',\n    '+', '-',\n    '=', '<>', '><', '<', '>', '<=', '>=', '=>',\n    'NOT',\n    'AND',\n    'OR',\n    'XOR',\n    // 1 XOR 1 = 0\n    // 1 XOR 0 = 1\n    // 0 XOR 1 = 1\n    // 0 XOR 0 = 0\n    'EQV',\n    // 1 EQV 1 = 1\n    // 1 EQV 0 = 0\n    // 0 EQV 1 = 0\n    // 0 EQV 0 = 1\n    'IMP',\n    // 0 IMP 0 = 1\n    // 0 IMP 1 = 1\n    // 1 IMP 0 = 0\n    // 1 IMP 1 = 1\n    ','\n], (kw, begin, end) => { return new OperatorLex(kw, begin, end); });\nclass StatementLex extends KeyWordLex {\n    constructor(keyWord, begin, end) {\n        super(keyWord, begin, end);\n        this.kind = 'StatementLex';\n    }\n    get LET() { return this.keyWord.toUpperCase() == 'LET'; }\n    get RUN() { return this.keyWord.toUpperCase() == 'RUN'; }\n    get GOTO() {\n        if (this.keyWord.toUpperCase() == 'GOTO')\n            return true;\n        if (this.keyWord.toUpperCase() == 'GO TO')\n            return true;\n        return false;\n    }\n    get IF() { return this.keyWord.toUpperCase() == 'IF'; }\n    get THEN() { return this.keyWord.toUpperCase() == 'THEN'; }\n    get ELSE() { return this.keyWord.toUpperCase() == 'ELSE'; }\n    get GOSUB() {\n        if (this.keyWord.toUpperCase() == 'GO SUB')\n            return true;\n        if (this.keyWord.toUpperCase() == 'GOSUB')\n            return true;\n        return false;\n    }\n    get RETURN() { return this.keyWord.toUpperCase() == 'RETURN'; }\n    get PRINT() { return this.keyWord.toUpperCase() == 'PRINT'; }\n    get CALL() { return this.keyWord.toUpperCase() == 'CALL'; }\n}\nexports.StatementLex = StatementLex;\n//get LIST() { return this.keyWord.toUpperCase()=='LIST' }\nStatementLex.parse = KeyWordLex.parser(true, [\n    'LET',\n    'RUN',\n    'GOTO',\n    'GO TO',\n    'IF',\n    'THEN',\n    'ELSE',\n    'GO SUB',\n    'GOSUB',\n    'RETURN',\n    'PRINT',\n    'CALL',\n], (kw, begin, end) => { return new StatementLex(kw, begin, end); });\n/**\n * Пустая лексема\n */\nclass DummyLex extends AbstractLex {\n    constructor() {\n        super(...arguments);\n        this.kind = 'DummyLex';\n    }\n}\nexports.DummyLex = DummyLex;\n/**\n * Лексема коментарий\n */\nclass RemLex extends AbstractLex {\n    constructor(cmnt, begin, end) {\n        super(begin, end);\n        this.kind = 'RemLex';\n        this.comment = cmnt;\n    }\n    static parse(str, off) {\n        if (off >= str.length)\n            return null;\n        let rm1 = str.substring(off, off + 4);\n        if (rm1.toUpperCase() == 'REM') {\n            return new RemLex('', off, off + rm1.length);\n        }\n        if (!(rm1.toUpperCase() == 'REM '))\n            return null;\n        let begin = off;\n        off += 4;\n        while (true) {\n            if (off >= str.length)\n                break;\n            if (Chars.isNewline(str.substring(off, off + 1))) {\n                break;\n            }\n            off++;\n        }\n        let end = off;\n        let cmntBegin = begin + 4;\n        return new RemLex(str.substring(cmntBegin, end), begin, end);\n    }\n}\nexports.RemLex = RemLex;\n/**\n * См https://robhagemans.github.io/pcbasic/doc/1.2/#literals\n */\nclass NumberLex extends AbstractLex {\n    constructor(val, integer, begin, end) {\n        super(begin, end);\n        this.value = val;\n        this.integer = integer;\n        this.kind = 'NumberLiteral';\n    }\n    static parseOct(str, off) {\n        //console.log(\"parseOct\")\n        if (off >= str.length)\n            return null;\n        let head = str.substring(off, off + 2);\n        if (!(head == '&o' || head == '&O'))\n            return null;\n        let num = 0;\n        let kSys = 8;\n        let begin = off;\n        off += 2;\n        while (true) {\n            if (off >= str.length)\n                break;\n            let chDgt = str.substring(off, off + 1);\n            if (!Chars.isOctDigit(chDgt)) {\n                break;\n            }\n            num = num * kSys + Chars.octDigit(chDgt);\n            off++;\n        }\n        let end = off;\n        return new NumberLex(num, true, begin, end);\n    }\n    static parseHex(str, off) {\n        //console.log(\"parseHex\")\n        if (off >= str.length)\n            return null;\n        let head = str.substring(off, off + 2);\n        if (!(head == '&h' || head == '&H'))\n            return null;\n        let num = 0;\n        let kSys = 16;\n        let begin = off;\n        off += 2;\n        while (true) {\n            if (off >= str.length)\n                break;\n            let chDgt = str.substring(off, off + 1);\n            if (!Chars.isHexDigit(chDgt)) {\n                break;\n            }\n            num = num * kSys + Chars.hexDigit(chDgt);\n            off++;\n        }\n        let end = off;\n        return new NumberLex(num, true, begin, end);\n    }\n    static parseDec(str, off) {\n        //console.log(\"parseDec\")\n        if (off >= str.length)\n            return null;\n        let head = str.substring(off);\n        /*\n        > \"+1234.22e+6%\".match( /^([+\\-]\\d+)((\\.\\d+)(([eEdD])([+\\-]?\\d+))?)?([%\\#!])?/ )\n        [ '+1234.22e+6%',\n        '+1234',\n        '.22e+6',\n        '.22',\n        'e+6',\n        'e',\n        '+6',\n        '%',\n        index: 0,\n        input: '+1234.22e+6%',\n        groups: undefined ]\n        */\n        let m1 = head.match(/^([+\\-]?\\d+)((\\.\\d+)(([eEdD])([+\\-]?\\d+))?)?([%\\#!])?/);\n        if (m1) {\n            let integer = true;\n            let p1 = m1[1];\n            if (m1[3])\n                p1 = p1 + m1[3]; //float part\n            if (m1[5] && (m1[5] == 'e' || m1[5] == 'E')) {\n                p1 = p1 + m1[4]; // expo\n                integer = false;\n            }\n            if (m1[5] && (m1[5] == 'd' || m1[5] == 'D')) {\n                integer = false;\n            }\n            if (m1[3] && m1[3].length > 0) {\n                integer = false;\n            }\n            let num = parseFloat(p1);\n            let begin = off;\n            let end = off + m1[0].length;\n            return new NumberLex(num, integer, begin, end);\n        }\n        return null;\n    }\n    static parse(str, off) {\n        let octn = NumberLex.parseOct(str, off);\n        if (octn)\n            return octn;\n        let hexn = NumberLex.parseHex(str, off);\n        if (hexn)\n            return hexn;\n        let decn = NumberLex.parseDec(str, off);\n        return decn;\n    }\n    /**\n     * Конвертирует в номер исходной строки\n     */\n    get asSourceLine() {\n        return new SourceLineBeginLex(this.value, this.begin, this.end);\n    }\n}\nexports.NumberLex = NumberLex;\n/**\n * Строковая лексема\n */\nclass StringLex extends AbstractLex {\n    constructor(val, begin, end) {\n        super(begin, end);\n        this.value = val;\n        this.kind = 'StringLiteral';\n    }\n    static parse(str, off) {\n        if (off >= str.length)\n            return null;\n        if (!(str.substring(off, off + 1) == '\"'))\n            return null;\n        let begin = off;\n        off++;\n        let sBegin = off;\n        let sEnd = -1;\n        while (true) {\n            if (off >= str.length)\n                break;\n            let ch = str.substring(off, off + 1);\n            if (ch == '\"') {\n                sEnd = off;\n                off++;\n                break;\n            }\n            if (Chars.isNewline(ch)) {\n                sEnd = off;\n                break;\n            }\n            off++;\n        }\n        let end = off;\n        let sVal = str.substring(sBegin, off);\n        if (sEnd > sBegin) {\n            sVal = str.substring(sBegin, sEnd);\n        }\n        return new StringLex(sVal, begin, end);\n    }\n}\nexports.StringLex = StringLex;\n/**\n * Идентификатор\n */\nclass IDLex extends AbstractLex {\n    constructor(id, begin, end) {\n        super(begin, end);\n        this.kind = 'ID';\n        this.id = id;\n    }\n    static parse(str, off) {\n        if (off >= str.length)\n            return null;\n        let head = str.substring(off);\n        let m1 = head.match(/^[a-zA-Z][a-zA-Z0-9\\.]*[\\#\\!\\%\\$]?/);\n        if (m1) {\n            let s = m1[0];\n            return new IDLex(s, off, off + s.length);\n        }\n        return null;\n    }\n}\nexports.IDLex = IDLex;\n/**\n * Лексемы языка BASIC\n */\nexports.basicLexems = [\n    NewLineLex.parse,\n    WhiteSpaceLex.parse,\n    RemLex.parse,\n    StatementLex.parse,\n    OperatorLex.parse,\n    IDLex.parse,\n    NumberLex.parse,\n    StringLex.parse,\n];\n/**\n * Маркер начала строки\n */\nclass SourceLineBeginLex extends AbstractLex {\n    constructor(line, begin, end) {\n        super(begin, end);\n        this.line = line;\n        this.kind = 'SourceLine';\n    }\n}\nexports.SourceLineBeginLex = SourceLineBeginLex;\n/**\n * Фильтр лексем\n */\nclass LexIterate {\n    constructor(lexs) {\n        this.lexs = lexs;\n    }\n    get() { return this.lexs; }\n    /**\n     * Удаляет лексемы пробельных символов\n     */\n    get dropWhitespace() {\n        let lexs = [];\n        for (let lx of this.lexs) {\n            if (!(lx instanceof WhiteSpaceLex)) {\n                lexs.push(lx);\n            }\n        }\n        return new LexIterate(lexs);\n    }\n    /**\n     * Удаляет лексемы перевода строк\n     */\n    get dropNewLines() {\n        let lexs = [];\n        for (let lx of this.lexs) {\n            if (!(lx instanceof NewLineLex)) {\n                lexs.push(lx);\n            }\n        }\n        return new LexIterate(lexs);\n    }\n    /**\n     * Разбивает лексемы на набор строк\n     */\n    get lines() {\n        let lines = [];\n        let line = [];\n        for (let lx of this.lexs) {\n            if (lx instanceof SourceLineBeginLex) {\n                if (line.length > 0) {\n                    lines.push(line);\n                }\n                line = [lx];\n            }\n            else {\n                line.push(lx);\n            }\n        }\n        if (line.length > 0) {\n            lines.push(line);\n        }\n        return lines;\n    }\n}\nexports.LexIterate = LexIterate;\n/**\n * Фильтр лексем\n * @param lexs лексемы\n */\nfunction filter(lexs) {\n    return new LexIterate(lexs);\n}\nexports.filter = filter;\nconst isStatement = (lx) => {\n    if (lx == undefined)\n        return false;\n    if (lx == null)\n        return false;\n    if (lx instanceof RemLex)\n        return true;\n    if (lx instanceof StatementLex)\n        return true;\n    return false;\n};\n/**\n * Лексический анализ\n * @param source исходный текст\n */\nfunction parseBasicLexs(source) {\n    let lexs = lexems(source, exports.basicLexems);\n    lexs = filter(lexs).dropWhitespace.lexs;\n    let res = [];\n    for (let i = 0; i < lexs.length; i++) {\n        if (i == 0) {\n            if (lexs[i] instanceof NumberLex &&\n                (i + 1) < lexs.length &&\n                isStatement(lexs[i + 1])) {\n                res.push(new SourceLineBeginLex(lexs[i].value, lexs[i].begin, lexs[i].end));\n            }\n            else {\n                res.push(lexs[i]);\n            }\n        }\n        else {\n            if (lexs[i - 1] instanceof NewLineLex &&\n                lexs[i] instanceof NumberLex) {\n                res.push(new SourceLineBeginLex(lexs[i].value, lexs[i].begin, lexs[i].end));\n            }\n            else {\n                res.push(lexs[i]);\n            }\n        }\n    }\n    //return res\n    return filter(res).dropNewLines.lexs;\n}\nexports.parseBasicLexs = parseBasicLexs;\n//# sourceMappingURL=Lexer.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/Lexer.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/OperatorExp.js":
/*!*******************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/OperatorExp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst TreeIt_1 = __webpack_require__(/*! ../common/TreeIt */ \"./node_modules/ts-basic-core/common/TreeIt.js\");\nclass AExpression {\n    get treeSize() {\n        if (this.treeSizeValue !== undefined)\n            return this.treeSizeValue;\n        this.treeSizeValue = this.treeList.length;\n        return this.treeSizeValue;\n    }\n    get treeList() {\n        return TreeIt_1.TreeIt.list(this, (n) => n.children);\n    }\n    get treeLexList() {\n        const arr = [];\n        this.treeList.forEach(exp => {\n            exp.value.lexems.forEach(lx => arr.push(lx));\n        });\n        return arr;\n    }\n    get leftTreeLex() {\n        const lxs = this.treeLexList;\n        if (lxs.length < 1)\n            return undefined;\n        if (lxs.length == 1)\n            return lxs[0];\n        return lxs.reduce((a, b) => a.begin > b.begin ? b : a);\n    }\n    get rightTreeLex() {\n        const lxs = this.treeLexList;\n        if (lxs.length < 1)\n            return undefined;\n        if (lxs.length == 1)\n            return lxs[0];\n        return lxs.reduce((a, b) => a.begin > b.begin ? a : b);\n    }\n}\nexports.AExpression = AExpression;\n/**\n * Константное значение (Литерал - строка/число/и т.д...)\n */\nclass LiteralExpression extends AExpression {\n    constructor(lex, value) {\n        super();\n        this.lex = lex;\n        this.value = value;\n        this.lexems = [lex];\n        this.children = [];\n        this.kind = 'Literal';\n    }\n}\nexports.LiteralExpression = LiteralExpression;\n/**\n * Ссылка на переменную\n */\nclass VarRefExpression extends AExpression {\n    constructor(lex) {\n        super();\n        this.id = lex;\n        this.lexems = [lex];\n        this.children = [];\n        this.kind = 'VarRef';\n    }\n    get varname() { return this.id.id; }\n}\nexports.VarRefExpression = VarRefExpression;\n/**\n * Ссылка на значение массива\n */\nclass VarArrIndexRef extends VarRefExpression {\n    constructor(lex, indexes) {\n        super(lex);\n        this.indexes = indexes;\n    }\n}\nexports.VarArrIndexRef = VarArrIndexRef;\n/**\n * Бинарная операция\n */\nclass BinaryOpExpression extends AExpression {\n    constructor(op, left, right) {\n        super();\n        this.operator = op;\n        this.left = left;\n        this.right = right;\n        this.lexems = [op];\n        this.children = [left, right];\n        this.kind = 'BinaryOperator';\n    }\n}\nexports.BinaryOpExpression = BinaryOpExpression;\n/**\n * Унраная операция\n */\nclass UnaryOpExpression extends AExpression {\n    constructor(op, base) {\n        super();\n        this.operator = op;\n        this.base = base;\n        this.lexems = [op];\n        this.children = [base];\n        this.kind = 'UnaryOperator';\n    }\n}\nexports.UnaryOpExpression = UnaryOpExpression;\n//# sourceMappingURL=OperatorExp.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/OperatorExp.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/Parser.js":
/*!**************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/Parser.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Pointer_1 = __webpack_require__(/*! ./Pointer */ \"./node_modules/ts-basic-core/ast/Pointer.js\");\nconst Lexer_1 = __webpack_require__(/*! ./Lexer */ \"./node_modules/ts-basic-core/ast/Lexer.js\");\nconst RemStatement_1 = __webpack_require__(/*! ./RemStatement */ \"./node_modules/ts-basic-core/ast/RemStatement.js\");\nconst Statements_1 = __webpack_require__(/*! ./Statements */ \"./node_modules/ts-basic-core/ast/Statements.js\");\nconst OperatorExp_1 = __webpack_require__(/*! ./OperatorExp */ \"./node_modules/ts-basic-core/ast/OperatorExp.js\");\nconst LetStatement_1 = __webpack_require__(/*! ./LetStatement */ \"./node_modules/ts-basic-core/ast/LetStatement.js\");\nconst RunStatement_1 = __webpack_require__(/*! ./RunStatement */ \"./node_modules/ts-basic-core/ast/RunStatement.js\");\nconst GotoStatement_1 = __webpack_require__(/*! ./GotoStatement */ \"./node_modules/ts-basic-core/ast/GotoStatement.js\");\nconst IfStatement_1 = __webpack_require__(/*! ./IfStatement */ \"./node_modules/ts-basic-core/ast/IfStatement.js\");\nconst GoSubStatement_1 = __webpack_require__(/*! ./GoSubStatement */ \"./node_modules/ts-basic-core/ast/GoSubStatement.js\");\nconst ReturnStatement_1 = __webpack_require__(/*! ./ReturnStatement */ \"./node_modules/ts-basic-core/ast/ReturnStatement.js\");\nconst PrintStatement_1 = __webpack_require__(/*! ./PrintStatement */ \"./node_modules/ts-basic-core/ast/PrintStatement.js\");\nconst CallStatement_1 = __webpack_require__(/*! ./CallStatement */ \"./node_modules/ts-basic-core/ast/CallStatement.js\");\n/**\n * Опции парсера\n */\nclass Options {\n    constructor() {\n        /**\n         * парсинг statement с учетом номера строки\n         */\n        this.tryLineNum = true;\n    }\n    /**\n     * Клонирование\n     */\n    clone(conf) {\n        const c = new Options();\n        c.tryLineNum = this.tryLineNum;\n        if (conf) {\n            conf(c);\n        }\n        return c;\n    }\n}\nexports.Options = Options;\n/**\n * Парсинг BASIC\n */\nclass Parser {\n    /**\n     * Конструктор\n     * @param lexs лексемы\n     */\n    constructor(lexs) {\n        this.debug = false;\n        /**\n         * Опции\n         */\n        this.options = new Options();\n        this.ptr = new Pointer_1.Pointer(lexs);\n    }\n    /**\n     * Конструктор\n     * @param source исходный текст\n     */\n    static create(source) {\n        return new Parser(Lexer_1.parseBasicLexs(source));\n    }\n    log(...args) {\n        if (this.debug) {\n            console.log(...args);\n        }\n    }\n    /**\n     * statements ::= { statement }\n     */\n    statements() {\n        const res = [];\n        if (this.ptr.eof)\n            return null;\n        const total = this.ptr.entries.length;\n        const tailEntries = this.ptr.gets(total - this.ptr.ptr);\n        const lines = Lexer_1.filter(tailEntries).lines;\n        let firstLex = null;\n        let lastLex = null;\n        this.log(\"statements() lines:\", lines);\n        for (let li = 0; li < lines.length; li++) {\n            const lineLex = lines[li];\n            if (firstLex == null && lineLex.length > 0) {\n                firstLex = lineLex[0];\n            }\n            if (lineLex.length > 0) {\n                lastLex = lineLex[lineLex.length - 1];\n            }\n            this.log(\"statements() line:\", lineLex);\n            const lineParser = new Parser(lineLex);\n            lineParser.debug = this.debug;\n            while (!lineParser.ptr.eof) {\n                const lineStatement = lineParser.statement();\n                if (lineStatement) {\n                    res.push(lineStatement);\n                }\n                else {\n                    throw new Error(\"can't parse line: \" + JSON.stringify(lineParser.ptr.gets(5)));\n                }\n            }\n        }\n        if (firstLex != null && lastLex != null) {\n            return new Statements_1.Statements(firstLex, lastLex, res);\n        }\n        return new Statements_1.Statements(new Lexer_1.DummyLex(-1, -1), new Lexer_1.DummyLex(-1, -1), res);\n    }\n    /**\n     * statement ::= remStatement\n     *             | letStatement\n     *             | runStatement\n     *             | gotoStatement\n     *             | ifStatement\n     *             | gosubStatement\n     *             | returnStatement\n     *             | printStatement\n     *             | callStatement\n     */\n    statement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        this.log('statement() ptr=', this.ptr.gets(3));\n        const remStmt = this.remStatement(opts);\n        if (remStmt)\n            return remStmt;\n        const letStmt = this.letStatement(opts);\n        if (letStmt)\n            return letStmt;\n        const runStmt = this.runStatement(opts);\n        if (runStmt)\n            return runStmt;\n        const gotoStmt = this.gotoStatement(opts);\n        if (gotoStmt)\n            return gotoStmt;\n        const ifStmt = this.ifStatement(opts);\n        if (ifStmt)\n            return ifStmt;\n        const gosubStmt = this.gosubStatement(opts);\n        if (gosubStmt)\n            return gosubStmt;\n        const returnStmt = this.returnStatement(opts);\n        if (returnStmt)\n            return returnStmt;\n        const printStmt = this.printStatement(opts);\n        if (printStmt)\n            return printStmt;\n        const callStmt = this.callStatement(opts);\n        if (callStmt)\n            return callStmt;\n        return null;\n    }\n    /**\n     * Проверка если текущая лексема обозначает начало нумерованной строки,\n     * то лексема и номер строки передается в функцию,\n     * а указатель смещается к след лексеме.\n     *\n     * Функция модет вернуть null, тогда будет восстановлена позиция\n     * @param proc функция принимающая номер строки\n     */\n    matchLine(proc) {\n        let lineNum = undefined;\n        let lineNumLex = this.ptr.get(0);\n        if ((lineNumLex instanceof Lexer_1.SourceLineBeginLex\n            || lineNumLex instanceof Lexer_1.NumberLex)) {\n            if (lineNumLex instanceof Lexer_1.SourceLineBeginLex) {\n                lineNum = lineNumLex.line;\n            }\n            if (lineNumLex instanceof Lexer_1.NumberLex) {\n                lineNum = lineNumLex.value;\n            }\n            if (lineNum) {\n                this.ptr.push();\n                this.ptr.move(1);\n                let res = proc({ line: lineNum, lex: lineNumLex });\n                if (res) {\n                    this.ptr.drop();\n                    return res;\n                }\n                this.ptr.pop();\n            }\n        }\n        return null;\n    }\n    /**\n     * remStatement ::= SourceLineBeginLex RemLex\n     *                | NumberLex RemLex\n     *                | RemLex\n     */\n    remStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        let [lex1, lex2] = this.ptr.gets(2);\n        if (lex1 instanceof Lexer_1.SourceLineBeginLex && lex2 instanceof Lexer_1.RemLex && opts.tryLineNum) {\n            this.ptr.move(2);\n            return new RemStatement_1.RemStatement(lex1, lex2, lex2);\n        }\n        if (lex1 instanceof Lexer_1.NumberLex && lex2 instanceof Lexer_1.RemLex && opts.tryLineNum) {\n            this.ptr.move(2);\n            return new RemStatement_1.RemStatement(lex1.asSourceLine, lex2, lex2);\n        }\n        if (lex1 instanceof Lexer_1.RemLex) {\n            this.ptr.move(1);\n            return new RemStatement_1.RemStatement(lex1, lex1, lex1);\n        }\n        return null;\n    }\n    /**\n     * letStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                  StatementLex(LET) IDLex OperatorLex(=) expression\n     */\n    letStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        // let lineNum : number | undefined = undefined\n        // let lineNumLex = this.ptr.get(0)\n        // let off = 0\n        // if( opts.tryLineNum && \n        //     (  lineNumLex instanceof SourceLineBeginLex \n        //     || lineNumLex instanceof NumberLex \n        //     )\n        // ){\n        //     if( lineNumLex instanceof SourceLineBeginLex ){\n        //         lineNum = lineNumLex.line\n        //     }\n        //     if( lineNumLex instanceof NumberLex ){\n        //         lineNum = lineNumLex.value\n        //     }\n        //     off = 1\n        // }\n        const prod = (arg) => {\n            this.ptr.push();\n            let lexLet = this.ptr.get();\n            if (lexLet instanceof Lexer_1.StatementLex && lexLet.LET) {\n                this.ptr.move(1);\n            }\n            else {\n                this.ptr.pop();\n                return null;\n            }\n            const lexId = this.ptr.get();\n            if (lexId instanceof Lexer_1.IDLex) {\n                const lxNext = this.ptr.get(1);\n                if (lxNext instanceof Lexer_1.OperatorLex && lxNext.keyWord == '=') {\n                    this.ptr.move(2);\n                    const exp = this.expression();\n                    if (exp) {\n                        const begin = arg ? arg.lex : lexLet;\n                        let end = exp.rightTreeLex || begin;\n                        this.ptr.drop();\n                        return new LetStatement_1.LetStatement(begin, end, lexId, exp);\n                    }\n                }\n                // if( lxNext instanceof OperatorLex && lxNext.arrBrOpen ){\n                //     this.ptr.move(2)\n                //     //let exp\n                // }\n            }\n            this.ptr.pop();\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n        // let lexLet = this.ptr.get(off)\n        // if( lexLet instanceof StatementLex && \n        //     lexLet.LET\n        // ){\n        //     let [ lexId, lxNext ] = this.ptr.fetch(off+1,2)\n        //     if( lxNext instanceof OperatorLex && lxNext.keyWord == '=' \n        //     &&  lexId instanceof IDLex\n        //     ){\n        //         // parsing...\n        //         this.ptr.push()\n        //         let begin = this.ptr.get() || lexLet\n        //         this.ptr.move(off+3)\n        //         let exp = this.expression()\n        //         if( exp ){\n        //             this.ptr.drop()\n        //             let end = exp.rightTreeLex || begin\n        //             return new LetStatement(begin,end,lexId,exp)\n        //         }else{\n        //             // syntax error\n        //             this.ptr.pop()\n        //             return null\n        //         }\n        //     }else{\n        //         // syntax error\n        //         return null\n        //     }\n        // }\n        // return null\n    }\n    /**\n     * runStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                  StatementLex(RUN) [lineNumber : NumberLex]\n     */\n    runStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('runStatement() ptr=', this.ptr.gets(3));\n        let lineNum = undefined;\n        let lineNumLex = this.ptr.get(0);\n        let off = 0;\n        if (opts.tryLineNum &&\n            (lineNumLex instanceof Lexer_1.SourceLineBeginLex\n                || lineNumLex instanceof Lexer_1.NumberLex)) {\n            if (lineNumLex instanceof Lexer_1.SourceLineBeginLex) {\n                lineNum = lineNumLex.line;\n            }\n            if (lineNumLex instanceof Lexer_1.NumberLex) {\n                lineNum = lineNumLex.value;\n            }\n            off = 1;\n        }\n        let runLex = this.ptr.get(off);\n        if (runLex instanceof Lexer_1.StatementLex &&\n            runLex.RUN) {\n            this.log('runStatement() RUN');\n            let runLineLex = this.ptr.get(off + 1);\n            if (runLineLex instanceof Lexer_1.NumberLex) {\n                off += 2;\n                this.ptr.move(off);\n                this.log('runStatement() move ', off, { eof: this.ptr.eof,\n                    gets3: this.ptr.gets(3)\n                });\n                return new RunStatement_1.RunStatement(lineNumLex || runLex, runLineLex, runLineLex);\n            }\n            off += 1;\n            this.ptr.move(off);\n            return new RunStatement_1.RunStatement(lineNumLex || runLex, runLex);\n        }\n        return null;\n    }\n    /**\n     * gotoStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                   StatementLex(GOTO) lineNumber:NumberLex\n     * @param opts опции компилятора\n     */\n    gotoStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('gotoStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let [gtLex, gtLine] = this.ptr.gets(2);\n            if (gtLex instanceof Lexer_1.StatementLex\n                && gtLex.GOTO\n                && gtLine instanceof Lexer_1.NumberLex) {\n                this.ptr.move(2);\n                return new GotoStatement_1.GotoStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n            }\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * gosubStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                   StatementLex(GOSUB) lineNumber:NumberLex\n     * @param opts опции компилятора\n     */\n    gosubStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('gosubStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let [gtLex, gtLine] = this.ptr.gets(2);\n            if (gtLex instanceof Lexer_1.StatementLex\n                && gtLex.GOSUB\n                && gtLine instanceof Lexer_1.NumberLex) {\n                this.ptr.move(2);\n                return new GoSubStatement_1.GoSubStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n            }\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * returnStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                   StatementLex(RETURN) [lineNumber:NumberLex]\n     * @param opts опции компилятора\n     */\n    returnStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('returnStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let [gtLex] = this.ptr.gets(1);\n            if (gtLex instanceof Lexer_1.StatementLex\n                && gtLex.RETURN) {\n                this.ptr.move(1);\n                let [gtLine] = this.ptr.fetch(0, 1);\n                if (gtLine instanceof Lexer_1.NumberLex) {\n                    this.ptr.move(1);\n                    return new ReturnStatement_1.ReturnStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n                }\n                else {\n                    return new ReturnStatement_1.ReturnStatement(linf ? linf.lex : gtLex, gtLine);\n                }\n            }\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * ifStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                 StatementLex(IF) expression\n     *                 StatementLex(THEN) statement\n     *                 [StatementLex(ELSE) statement]\n     * @param opts опции компилятора\n     */\n    ifStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('ifStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let ifLx = this.ptr.get();\n            this.log(\"ifLx \", ifLx);\n            if (!ifLx)\n                return null;\n            if (!(ifLx instanceof Lexer_1.StatementLex))\n                return null;\n            if (!(ifLx.IF))\n                return null;\n            this.ptr.push();\n            this.ptr.move(1);\n            let exp = this.expression();\n            if (!exp) {\n                this.ptr.pop();\n                return null;\n            }\n            let thenLx = this.ptr.get();\n            if (thenLx instanceof Lexer_1.StatementLex && !thenLx.THEN) {\n                this.ptr.pop();\n                return null;\n            }\n            this.ptr.move(1);\n            const conf = (op) => { op.tryLineNum = false; };\n            let trueSt = this.statement(opts ? opts.clone(conf) : this.options.clone(conf));\n            if (trueSt == null) {\n                this.ptr.pop();\n                return null;\n            }\n            let elseLx = this.ptr.get();\n            let falseSt = null;\n            if (elseLx instanceof Lexer_1.StatementLex && elseLx.ELSE) {\n                this.ptr.push();\n                this.ptr.move(1);\n                falseSt = this.statement(opts ? opts.clone(conf) : this.options.clone(conf));\n                if (falseSt) {\n                    this.ptr.drop();\n                }\n                else {\n                    this.ptr.pop();\n                }\n            }\n            this.ptr.drop();\n            if (falseSt) {\n                return new IfStatement_1.IfStatement(linf ? linf.lex : ifLx, falseSt ? falseSt.end : trueSt.end, exp, trueSt, falseSt);\n            }\n            return new IfStatement_1.IfStatement(linf ? linf.lex : ifLx, trueSt.end, exp, trueSt);\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * printStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                    StatementLex(PRINT) [expression {',' expression}]\n     * @param opts опции компилятора\n     */\n    printStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('printStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let [gtLex] = this.ptr.gets(1);\n            if (gtLex instanceof Lexer_1.StatementLex\n                && gtLex.PRINT) {\n                this.ptr.move(1);\n                const exps = [];\n                let lastLex = gtLex;\n                while (true) {\n                    if (exps.length > 0) {\n                        const lNext = this.ptr.get();\n                        if (!(lNext && lNext instanceof Lexer_1.OperatorLex && lNext.argDelim)) {\n                            break;\n                        }\n                        else {\n                            this.ptr.move(1);\n                        }\n                    }\n                    this.ptr.push();\n                    const exp = this.expression();\n                    if (exp) {\n                        exps.push(exp);\n                        if (exp.rightTreeLex) {\n                            lastLex = exp.rightTreeLex;\n                        }\n                    }\n                    else {\n                        this.ptr.pop();\n                        if (exps.length > 0) {\n                            //TODO here error report\n                        }\n                        break;\n                    }\n                }\n                return new PrintStatement_1.PrintStatement(linf ? linf.lex : gtLex, lastLex, gtLex, exps);\n            }\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * callStatement ::= [ SourceLineBeginLex | NumberLex ]\n     *                    StatementLex(CALL) IDLex [expression {',' expression}]\n     * @param opts опции компилятора\n     */\n    callStatement(opts) {\n        if (!opts) {\n            opts = this.options;\n        }\n        if (this.ptr.eof)\n            return null;\n        this.log('callStatement() ptr=', this.ptr.gets(3));\n        const prod = (linf) => {\n            let [callLex, idLex] = this.ptr.gets(2);\n            if (callLex instanceof Lexer_1.StatementLex\n                && callLex.CALL\n                && idLex instanceof Lexer_1.IDLex) {\n                this.ptr.move(2);\n                const exps = [];\n                let lastLex = callLex;\n                while (true) {\n                    if (exps.length > 0) {\n                        const lNext = this.ptr.get();\n                        if (!(lNext && lNext instanceof Lexer_1.OperatorLex && lNext.argDelim)) {\n                            break;\n                        }\n                        else {\n                            this.ptr.move(1);\n                        }\n                    }\n                    this.ptr.push();\n                    const exp = this.expression();\n                    if (exp) {\n                        exps.push(exp);\n                        if (exp.rightTreeLex) {\n                            lastLex = exp.rightTreeLex;\n                        }\n                    }\n                    else {\n                        this.ptr.pop();\n                        if (exps.length > 0) {\n                            //TODO here error report\n                        }\n                        break;\n                    }\n                }\n                return new CallStatement_1.CallStatement(linf ? linf.lex : callLex, lastLex, callLex, idLex, exps);\n            }\n            return null;\n        };\n        if (opts.tryLineNum) {\n            return this.matchLine(prod) || prod();\n        }\n        else {\n            return prod();\n        }\n    }\n    /**\n     * expression ::= impExpression | bracketExpression\n     */\n    expression() {\n        this.log('expression() ptr=', this.ptr.gets(3));\n        let powExp = this.impExpression();\n        if (powExp)\n            return powExp;\n        let brExp = this.bracketExpression();\n        if (brExp)\n            return brExp;\n        return null;\n    }\n    /**\n     * bracketExpression ::= '(' expression ')'\n     */\n    bracketExpression() {\n        if (this.ptr.eof)\n            return null;\n        let leftBr = this.ptr.get(0);\n        if (leftBr instanceof Lexer_1.KeyWordLex && leftBr.keyWord == '(') {\n            this.ptr.push();\n            this.ptr.move(1);\n            let exp = this.expression();\n            if (exp) {\n                let rightBr = this.ptr.get(0);\n                if (rightBr instanceof Lexer_1.KeyWordLex && rightBr.keyWord == ')') {\n                    this.ptr.move(1);\n                    this.ptr.drop();\n                    return exp;\n                }\n            }\n            this.ptr.pop();\n        }\n        return null;\n    }\n    /**\n     * Парсинг циклической конструкции:\n     * leftOp { operator rightExp }\n     *\n     * Проверяет что текущая лексема (operator) соответ указанной (accpetOperator),\n     * и если это так, то производит анализ правого операнда (rightExp)\n     * В результате создает последовательность (дерево растет в лево)\n     * бинарных операторов\n     * @param ruleName имя правила\n     * @param leftOp левый уже вычесленный операнд\n     * @param rightExp вычисление правого операнда\n     * @param accpetOperator проверка оператора\n     */\n    binaryRepeatExpression(ruleName, leftOp, rightExp, accpetOperator) {\n        let res = leftOp;\n        while (true) {\n            let lx = this.ptr.get();\n            if (lx instanceof Lexer_1.OperatorLex && accpetOperator(lx)) {\n                this.ptr.move(1);\n                let rightOp = rightExp();\n                this.log(`${ruleName} right=`, rightOp);\n                if (rightOp) {\n                    this.ptr.drop();\n                    this.log(`${ruleName} succ=`, lx.keyWord, res, rightOp);\n                    res = new OperatorExp_1.BinaryOpExpression(lx, res, rightOp);\n                    lx = this.ptr.get();\n                    if (lx instanceof Lexer_1.OperatorLex && accpetOperator(lx)) {\n                        this.log(`${ruleName} has right ${lx.keyWord}`);\n                        this.ptr.push();\n                        continue;\n                    }\n                    return res;\n                }\n                else {\n                    this.ptr.pop();\n                    return null;\n                }\n            }\n            else {\n                this.ptr.drop();\n                return res;\n            }\n        }\n    }\n    /**\n     * impExpression ::= eqvExpression [ { 'IMP' eqvExpression } ]\n     */\n    impExpression() {\n        this.log('impExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.eqvExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('impExpression()', leftOp, () => this.eqvExpression(), (lx) => lx.imp);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * eqvExpression ::= xorExpression [ 'EQV' xorExpression ]\n     */\n    eqvExpression() {\n        this.log('eqvExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.xorExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('eqvExpression()', leftOp, () => this.xorExpression(), (lx) => lx.eqv);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * xorExpression ::= orExpression [ { 'XOR' orExpression } ]\n     */\n    xorExpression() {\n        this.log('xorExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.orExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('xorExpression()', leftOp, () => this.orExpression(), (lx) => lx.xor);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * orExpression ::= andExpression [ { 'OR' andExpression } ]\n     */\n    orExpression() {\n        this.log('orExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.andExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('orExpression()', leftOp, () => this.andExpression(), (lx) => lx.or);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * andExpression ::= notExpression [ { 'AND' notExpression } ]\n     */\n    andExpression() {\n        this.log('andExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.notExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('andExpression()', leftOp, () => this.notExpression(), (lx) => lx.and);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * notExpression ::= ['NOT'] relationExpression\n     */\n    notExpression() {\n        this.log('notExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        let lx = this.ptr.get();\n        if (lx instanceof Lexer_1.OperatorLex && lx.not) {\n            this.ptr.push();\n            this.ptr.move(1);\n            let exp = this.relationExpression();\n            if (exp) {\n                this.ptr.drop();\n                return new OperatorExp_1.UnaryOpExpression(lx, exp);\n            }\n            this.ptr.pop();\n            return null;\n        }\n        return this.relationExpression();\n    }\n    /**\n     * relationExpression ::= plusExpression [ ('=', '<>', '><', '<', '>', '>=', '<=', '=>', '=<') plusExpression ]\n     */\n    relationExpression() {\n        this.log('relationExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.plusExpression();\n        if (leftOp) {\n            let lx = this.ptr.get();\n            if (lx instanceof Lexer_1.OperatorLex && lx.ordReleation) {\n                this.ptr.move(1);\n                let rightOp = this.plusExpression();\n                if (rightOp) {\n                    this.ptr.drop();\n                    return new OperatorExp_1.BinaryOpExpression(lx, leftOp, rightOp);\n                }\n            }\n            else {\n                this.ptr.drop();\n                return leftOp;\n            }\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * plusExpression ::= modExpression [ { ('+' | '-') modExpression } ]\n     */\n    plusExpression() {\n        this.log('plusExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.modExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('plusExpression()', leftOp, () => this.modExpression(), (lx) => lx.plus || lx.minus);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * modExpression ::= intDivExpression [ { 'MOD' intDivExpression } ]\n     */\n    modExpression() {\n        this.log('modExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.intDivExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('modExpression()', leftOp, () => this.intDivExpression(), (lx) => lx.mod);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * intDivExpression ::= mulExpression [ { '\\' mulExpression } ]\n     */\n    intDivExpression() {\n        this.log('intDivExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.mulExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('intDivExpression()', leftOp, () => this.mulExpression(), (lx) => lx.idiv);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * mulExpression ::= powExpression [ { ( '*' | '/' ) powExpression } ]\n     */\n    mulExpression() {\n        this.log('mulExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.powExpression();\n        if (leftOp) {\n            return this.binaryRepeatExpression('mulExpression()', leftOp, () => this.powExpression(), (lx) => lx.mult || lx.div);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * powExpression ::= signedAtom [ { '^' signedAtom } ]\n     */\n    powExpression() {\n        this.log('powExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let leftOp = this.signedAtom();\n        if (leftOp) {\n            return this.binaryRepeatExpression('powExpression()', leftOp, () => this.signedAtom(), (lx) => lx.pow);\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * signedAtom ::= [ '+' | '-' ] atom\n     */\n    signedAtom() {\n        this.log('signedAtom() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        this.ptr.push();\n        let unary = false;\n        let unaryLx = this.ptr.get();\n        if (unaryLx instanceof Lexer_1.OperatorLex && (unaryLx.keyWord == '-' || unaryLx.keyWord == '+')) {\n            this.ptr.move(1);\n            unary = true;\n        }\n        let atom = this.atom();\n        if (atom) {\n            this.ptr.drop();\n            if (unary) {\n                return new OperatorExp_1.UnaryOpExpression(unaryLx, atom);\n            }\n            return atom;\n        }\n        this.ptr.pop();\n        return null;\n    }\n    /**\n     * atom ::= '(' expression ')'\n     *        | baseValueExpression\n     */\n    atom() {\n        this.log('atom() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        let leftBr = this.ptr.get(0);\n        if (leftBr instanceof Lexer_1.KeyWordLex && leftBr.keyWord == '(') {\n            this.ptr.push();\n            this.ptr.move(1);\n            let exp = this.expression();\n            if (exp) {\n                let rightBr = this.ptr.get(0);\n                if (rightBr instanceof Lexer_1.KeyWordLex && rightBr.keyWord == ')') {\n                    this.ptr.move(1);\n                    this.ptr.drop();\n                    return exp;\n                }\n            }\n            this.ptr.pop();\n        }\n        return this.baseValueExpression();\n    }\n    /**\n     * baseValueExpression ::= constExpression\n     *                       | varRefExpression '(' expression [{ ',' expression }] ')'\n     *                       | varRefExpression\n     */\n    baseValueExpression() {\n        this.log('baseValueExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        let cexpr = this.constExpression();\n        this.log('baseValueExpression() cexpr=', cexpr);\n        if (cexpr) {\n            this.log('baseValueExpression() res=', cexpr);\n            return cexpr;\n        }\n        let vrefExp = this.varRefExpression();\n        this.log('baseValueExpression() vrefExp=', vrefExp);\n        if (vrefExp) {\n            this.log('baseValueExpression() res=', vrefExp);\n            const brOpen = this.ptr.get();\n            if (brOpen instanceof Lexer_1.OperatorLex && brOpen.arrBrOpen) {\n                let parseArrSucc = true;\n                const indexExpression = [];\n                this.ptr.push();\n                this.ptr.move(1);\n                while (true) {\n                    const idxExp = this.expression();\n                    if (idxExp) {\n                        indexExpression.push(idxExp);\n                    }\n                    else {\n                        this.ptr.pop();\n                        parseArrSucc = false;\n                        break;\n                    }\n                    const lxNext = this.ptr.get();\n                    if (lxNext instanceof Lexer_1.OperatorLex) {\n                        if (lxNext.argDelim) {\n                            this.ptr.move(1);\n                            continue;\n                        }\n                        else if (lxNext.arrBrClose) {\n                            this.ptr.move(1);\n                            break;\n                        }\n                    }\n                }\n                if (parseArrSucc) {\n                    this.ptr.drop();\n                    return new OperatorExp_1.VarArrIndexRef(vrefExp.id, indexExpression);\n                }\n            }\n            return vrefExp;\n        }\n        return null;\n    }\n    /**\n     * constExpression ::= NumberLex | StringLex\n     */\n    constExpression() {\n        this.log('constExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        let lx = this.ptr.get();\n        if (lx instanceof Lexer_1.NumberLex) {\n            this.ptr.move(1);\n            return new OperatorExp_1.LiteralExpression(lx, lx.value);\n        }\n        if (lx instanceof Lexer_1.StringLex) {\n            this.ptr.move(1);\n            return new OperatorExp_1.LiteralExpression(lx, lx.value);\n        }\n        return null;\n    }\n    /**\n     * varRefExpression ::= IDLex\n     */\n    varRefExpression() {\n        this.log('varRefExpression() ptr=', this.ptr.gets(3));\n        if (this.ptr.eof)\n            return null;\n        let lx = this.ptr.get();\n        this.log('varRefExpression() lx=', lx);\n        if (lx instanceof Lexer_1.IDLex) {\n            this.log('varRefExpression() succ', lx);\n            this.ptr.move(1);\n            return new OperatorExp_1.VarRefExpression(lx);\n        }\n        return null;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=Parser.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/Parser.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/Pointer.js":
/*!***************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/Pointer.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Num_1 = __webpack_require__(/*! ../common/Num */ \"./node_modules/ts-basic-core/common/Num.js\");\n/**\n * Перемещаемый указатель по массиву\n */\nclass Pointer {\n    /**\n     * Конструктор\n     * @param entries текст\n     */\n    constructor(entries) {\n        /**\n         * Сохраненный стек указателей\n         */\n        this.stack = [];\n        this.pointerValue = 0;\n        this.entries = entries;\n    }\n    /**\n     * Возвращает указатель\n     */\n    get ptr() {\n        return this.pointerValue;\n    }\n    /**\n     * Устанавливает текущий казатель\n     */\n    set ptr(v) {\n        this.pointerValue = Num_1.asInt(v);\n    }\n    /**\n     * Возвращает прзнак что указать достигнул конец списка элементов\n     */\n    get eof() {\n        return this.ptr >= this.entries.length;\n    }\n    /**\n     * Смещение указателя на указанное число элементов\n     * @param n число элементов\n     */\n    move(n) {\n        this.pointerValue += Num_1.asInt(n);\n        return this.pointerValue;\n    }\n    /**\n     * Сохранение текущего указателя в стеке\n     */\n    push() {\n        this.stack.push(this.ptr);\n    }\n    /**\n     * Чтение сохраненного указателя из стека\n     */\n    peek() {\n        if (this.stack.length <= 0)\n            return null;\n        return this.stack[this.stack.length - 1];\n    }\n    /**\n     * Восстановление текущего указатель из стека с удалением значения из стека\n     */\n    pop() {\n        if (this.stack.length <= 0)\n            throw new Error(\"stack is empty\");\n        const v = this.stack.pop();\n        if (v !== undefined) {\n            this.ptr = v;\n        }\n        return this.ptr;\n    }\n    /**\n     * Удаление верхнего элемента стека без восстановления указателя\n     */\n    drop() {\n        if (this.stack.length <= 0)\n            throw new Error(\"stack is empty\");\n        this.stack.pop();\n        return this.ptr;\n    }\n    /**\n     * Полчение значения\n     * @param off смещение от текущей позиции\n     */\n    get(off = 0) {\n        let t = this.ptr + off;\n        if (t >= 0 && t < this.entries.length) {\n            return this.entries[t];\n        }\n        return null;\n    }\n    /**\n     * Получение массива значений\n     * @param off смещение от текущей позиции\n     * @param cnt максимальное кол-во значений\n     */\n    fetch(off = 0, cnt = 1) {\n        const res = [];\n        const start = this.ptr + off;\n        if (cnt <= 0)\n            return res;\n        for (let i = 0; i < cnt; i++) {\n            let ti = start + i;\n            if (ti >= 0 && ti < this.entries.length) {\n                res.push(this.entries[ti]);\n            }\n        }\n        return res;\n    }\n    /**\n     * Получение массива значений\n     * @param cnt максимальное кол-во значений\n     */\n    gets(cnt = 1) { return this.fetch(0, cnt); }\n}\nexports.Pointer = Pointer;\n//# sourceMappingURL=Pointer.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/Pointer.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/PrintStatement.js":
/*!**********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/PrintStatement.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass PrintStatement extends Statement_1.Statement {\n    constructor(begin, end, print, args) {\n        super();\n        this.kind = 'Print';\n        this.begin = begin;\n        this.end = end;\n        this.print = print;\n        this.args = args;\n    }\n}\nexports.PrintStatement = PrintStatement;\n//# sourceMappingURL=PrintStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/PrintStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/RemStatement.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/RemStatement.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass RemStatement extends Statement_1.Statement {\n    constructor(begin, end, rem) {\n        super();\n        this.kind = 'Rem';\n        this.begin = begin;\n        this.end = end;\n        this.rem = rem;\n    }\n}\nexports.RemStatement = RemStatement;\n//# sourceMappingURL=RemStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/RemStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/ReturnStatement.js":
/*!***********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/ReturnStatement.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass ReturnStatement extends Statement_1.Statement {\n    constructor(begin, end, line) {\n        super();\n        this.kind = 'Return';\n        this.begin = begin;\n        this.end = end;\n        this.gotoLine = line;\n    }\n}\nexports.ReturnStatement = ReturnStatement;\n//# sourceMappingURL=ReturnStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/ReturnStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/RunStatement.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/RunStatement.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass RunStatement extends Statement_1.Statement {\n    constructor(begin, end, line) {\n        super();\n        this.begin = begin;\n        this.end = end;\n        this.runLine = line;\n        this.kind = 'Run';\n    }\n}\nexports.RunStatement = RunStatement;\n//# sourceMappingURL=RunStatement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/RunStatement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/Statement.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/Statement.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Lexer_1 = __webpack_require__(/*! ./Lexer */ \"./node_modules/ts-basic-core/ast/Lexer.js\");\n/**\n * Некий кусок кода, который по традиции должен умещаться в одной строке\n */\nclass Statement {\n    /**\n     * Номер строки\n     */\n    get sourceLine() {\n        if (this.begin instanceof Lexer_1.SourceLineBeginLex) {\n            return this.begin.line;\n        }\n        return undefined;\n    }\n}\nexports.Statement = Statement;\n//# sourceMappingURL=Statement.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/Statement.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/ast/Statements.js":
/*!******************************************************!*\
  !*** ./node_modules/ts-basic-core/ast/Statements.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Statement_1 = __webpack_require__(/*! ./Statement */ \"./node_modules/ts-basic-core/ast/Statement.js\");\nclass Statements extends Statement_1.Statement {\n    constructor(begin, end, statements) {\n        super();\n        this.kind = \"Statements\";\n        this.begin = begin;\n        this.end = end;\n        this.statements = statements;\n    }\n}\nexports.Statements = Statements;\n//# sourceMappingURL=Statements.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/ast/Statements.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/common/Num.js":
/*!**************************************************!*\
  !*** ./node_modules/ts-basic-core/common/Num.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Возвращает целое число\n * @param n число\n */\nfunction asInt(n) { return n | 0; }\nexports.asInt = asInt;\n//# sourceMappingURL=Num.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/common/Num.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/common/TreeIt.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-basic-core/common/TreeIt.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Шаг очередной итерации\n */\nclass TreeStep {\n    /**\n     * Конструктор\n     * @param value Значение узла дерева\n     * @param parent Ссылка на родительский элемент дерева\n     */\n    constructor(value, parent) {\n        this.value = value;\n        this.parent = parent;\n    }\n    /**\n     * Создание дочернего пути/шага при обходе дерева\n     * @param value дочернее значение узла\n     */\n    follow(value) {\n        return new TreeStep(value, this);\n    }\n    /**\n     * Возвращает путь значений в дереве\n     */\n    get path() {\n        let res = [];\n        let ts = this;\n        while (ts != undefined && ts != null) {\n            res.push(ts.value);\n            ts = ts.parent;\n        }\n        res.reverse();\n        return res;\n    }\n}\nexports.TreeStep = TreeStep;\n/**\n * Итератор для обхода дерева\n */\nclass TreeIt {\n    /**\n     * Конструктор\n     * @param start начальный узел дерева\n     * @param follow функция перехода к дочерним узлам\n     */\n    constructor(start, follow) {\n        this.follow = follow;\n        this.current = [new TreeStep(start)];\n    }\n    /**\n     * Проверяет наличие дочернего узла\n     */\n    hasNext() {\n        return this.current.length > 0;\n    }\n    /**\n     * Переход к следующему узлу в дереве\n     */\n    fetch() {\n        if (this.current.length <= 0)\n            return undefined;\n        let res = this.current.splice(0, 1);\n        //let res:T|undefined = this.current.pop()\n        if (res != undefined) {\n            res.forEach(r => {\n                this.follow(r.value).forEach(n => this.current.push(r.follow(n)));\n            });\n        }\n        if (res != undefined) {\n            return res.length > 0 ? res[0] : undefined;\n        }\n        return undefined;\n    }\n    /**\n     * Обход узлов дерева\n     * @param start начальный узел дерева\n     * @param follow функция перехода к дочерним узлам\n     * @param consumer функция - визер узлов дерева\n     */\n    static each(start, follow, consumer) {\n        if (start == null || start == undefined)\n            throw new Error(\"illegal arg start\");\n        if (follow == null || follow == undefined)\n            throw new Error(\"illegal arg follow\");\n        if (consumer == null || consumer == undefined)\n            throw new Error(\"illegal arg consumer\");\n        const titer = new TreeIt(start, follow);\n        while (titer.hasNext()) {\n            let f = titer.fetch();\n            if (f) {\n                consumer(f);\n            }\n        }\n    }\n    /**\n     * Разворчивание дерева в список\n     * @param start начальный узел\n     * @param follow функция перехода к дочерним узлам\n     */\n    static list(start, follow) {\n        if (start == null || start == undefined)\n            throw new Error(\"illegal arg start\");\n        if (follow == null || follow == undefined)\n            throw new Error(\"illegal arg follow\");\n        let arr = [];\n        TreeIt.each(start, follow, (n) => { arr.push(n); });\n        return arr;\n    }\n}\nexports.TreeIt = TreeIt;\n//# sourceMappingURL=TreeIt.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/common/TreeIt.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/vm/BasicVm.js":
/*!**************************************************!*\
  !*** ./node_modules/ts-basic-core/vm/BasicVm.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst LetStatement_1 = __webpack_require__(/*! ../ast/LetStatement */ \"./node_modules/ts-basic-core/ast/LetStatement.js\");\nconst OperatorExp_1 = __webpack_require__(/*! ../ast/OperatorExp */ \"./node_modules/ts-basic-core/ast/OperatorExp.js\");\nconst Memo_1 = __webpack_require__(/*! ./Memo */ \"./node_modules/ts-basic-core/vm/Memo.js\");\nconst Num_1 = __webpack_require__(/*! ../common/Num */ \"./node_modules/ts-basic-core/common/Num.js\");\nconst RemStatement_1 = __webpack_require__(/*! ../ast/RemStatement */ \"./node_modules/ts-basic-core/ast/RemStatement.js\");\nconst RunStatement_1 = __webpack_require__(/*! ../ast/RunStatement */ \"./node_modules/ts-basic-core/ast/RunStatement.js\");\nconst GotoStatement_1 = __webpack_require__(/*! ../ast/GotoStatement */ \"./node_modules/ts-basic-core/ast/GotoStatement.js\");\nconst IfStatement_1 = __webpack_require__(/*! ../ast/IfStatement */ \"./node_modules/ts-basic-core/ast/IfStatement.js\");\nconst GoSubStatement_1 = __webpack_require__(/*! ../ast/GoSubStatement */ \"./node_modules/ts-basic-core/ast/GoSubStatement.js\");\nconst ReturnStatement_1 = __webpack_require__(/*! ../ast/ReturnStatement */ \"./node_modules/ts-basic-core/ast/ReturnStatement.js\");\nconst PrintStatement_1 = __webpack_require__(/*! ../ast/PrintStatement */ \"./node_modules/ts-basic-core/ast/PrintStatement.js\");\nconst Printer_1 = __webpack_require__(/*! ./Printer */ \"./node_modules/ts-basic-core/vm/Printer.js\");\nconst CallStatement_1 = __webpack_require__(/*! ../ast/CallStatement */ \"./node_modules/ts-basic-core/ast/CallStatement.js\");\nconst ExtFun_1 = __webpack_require__(/*! ./ExtFun */ \"./node_modules/ts-basic-core/vm/ExtFun.js\");\nclass BasicVm {\n    constructor(source, memo) {\n        this._printer = this.defaultPrinter;\n        /**\n         * Стек вызовов GoSub\n         */\n        this.ipStack = [];\n        /**\n         * Регистр IP (Instruction Pointer)\n         */\n        this.ip = -1;\n        this.source = source;\n        if (memo) {\n            this.memo = memo;\n        }\n        else {\n            this.memo = new Memo_1.Memo();\n        }\n    }\n    /**\n     * Вычисляет выражение (expression)\n     * @param exp выражение\n     */\n    evalExpression(exp) {\n        if (exp instanceof OperatorExp_1.LiteralExpression) {\n            return exp.value;\n        }\n        if (exp instanceof OperatorExp_1.VarArrIndexRef) {\n            const varInst = this.memo.read(exp.varname);\n            if (varInst == undefined) {\n                throw new Error(\"undefined variable \" + exp.varname);\n            }\n            if (varInst instanceof ExtFun_1.Fun) {\n                const ctx = new ExtFun_1.CallCtx(this, exp);\n                const fn = varInst;\n                const args = exp.indexes.map(e => this.evalExpression(e));\n                return fn.apply(ctx, args);\n            }\n            const res = this.memo.read(exp.varname, exp.indexes);\n            return res;\n        }\n        if (exp instanceof OperatorExp_1.VarRefExpression) {\n            const res = this.memo.read(exp.varname);\n            if (res == undefined)\n                throw new Error(\"undefined variable \" + exp.varname);\n            return res;\n        }\n        if (exp instanceof OperatorExp_1.UnaryOpExpression) {\n            if (exp.operator.minus)\n                return (0 - this.evalExpression(exp.base));\n            if (exp.operator.plus)\n                return this.evalExpression(exp.base);\n            if (exp.operator.not)\n                return !this.evalExpression(exp.base);\n            throw new Error(`undefined unary operator ${exp.operator.keyWord}`);\n        }\n        if (exp instanceof OperatorExp_1.BinaryOpExpression) {\n            //#region math\n            if (exp.operator.plus)\n                return (this.evalExpression(exp.left) + this.evalExpression(exp.right));\n            if (exp.operator.minus)\n                return (this.evalExpression(exp.left) - this.evalExpression(exp.right));\n            if (exp.operator.mult)\n                return (this.evalExpression(exp.left) * this.evalExpression(exp.right));\n            if (exp.operator.div)\n                return (this.evalExpression(exp.left) / this.evalExpression(exp.right));\n            if (exp.operator.idiv)\n                return Num_1.asInt(this.evalExpression(exp.left) / Num_1.asInt(this.evalExpression(exp.right)));\n            if (exp.operator.mod)\n                return Num_1.asInt(this.evalExpression(exp.left) % this.evalExpression(exp.right));\n            //#endregion\n            //#region logic\n            if (exp.operator.and)\n                return this.evalExpression(exp.left) && this.evalExpression(exp.right);\n            if (exp.operator.or)\n                return this.evalExpression(exp.left) || this.evalExpression(exp.right);\n            // TODO check type\n            if (exp.operator.xor)\n                return !(this.evalExpression(exp.left) == this.evalExpression(exp.right));\n            // TODO check type\n            if (exp.operator.eqv)\n                return this.evalExpression(exp.left) == this.evalExpression(exp.right);\n            if (exp.operator.imp) {\n                const l = this.evalExpression(exp.left);\n                const r = this.evalExpression(exp.right);\n                if (l) {\n                    if (r) {\n                        return true;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n                else {\n                    return true;\n                }\n            }\n            //#endregion\n            //#region compare\n            if (exp.operator.equals) {\n                return this.evalExpression(exp.left) == this.evalExpression(exp.right);\n            }\n            if (exp.operator.notEquals) {\n                return this.evalExpression(exp.left) != this.evalExpression(exp.right);\n            }\n            if (exp.operator.less) {\n                return this.evalExpression(exp.left) < this.evalExpression(exp.right);\n            }\n            if (exp.operator.lesOrEquals) {\n                return this.evalExpression(exp.left) <= this.evalExpression(exp.right);\n            }\n            if (exp.operator.more) {\n                return this.evalExpression(exp.left) > this.evalExpression(exp.right);\n            }\n            if (exp.operator.moreOrEquals) {\n                return this.evalExpression(exp.left) >= this.evalExpression(exp.right);\n            }\n            //#endregion\n            throw new Error(`undefined binary operator ${exp.operator.keyWord}`);\n        }\n        throw new Error(\"undefined expression \" + exp);\n    }\n    //#region Printing\n    get defaultPrinter() {\n        return Printer_1.printers.console.clone().configure(c => {\n            c.prefix = \"BASIC> \";\n        });\n    }\n    get printer() { return this._printer; }\n    set printer(x) {\n        if (x) {\n            this._printer = x;\n        }\n        else {\n            this._printer = this.defaultPrinter;\n        }\n    }\n    print(v) {\n        this.printer.print(v);\n    }\n    println() {\n        this.printer.println();\n    }\n    //#endregion\n    callProcudure(name, args, callst) {\n        const fnInst = this.memo.read(name);\n        if (typeof (fnInst) == 'object' && fnInst instanceof ExtFun_1.Fun) {\n            const fn = fnInst;\n            const ctx = new ExtFun_1.CallCtx(this, callst);\n            fn.apply(ctx, args);\n        }\n        else if (typeof (fnInst) == 'function') {\n            const fn = fnInst;\n            fn.apply({}, args);\n        }\n        else {\n            throw new Error(`can't call procedure ${name}, procedure not found`);\n        }\n    }\n    /**\n     * Выполняет выражение (statement)\n     * @param st выражение\n     */\n    evalStatement(st) {\n        if (st instanceof RemStatement_1.RemStatement) {\n            return;\n        }\n        if (st instanceof LetStatement_1.LetStatement) {\n            const val = this.evalExpression(st.value);\n            this.memo.write(st.varname, val);\n            return;\n        }\n        if (st instanceof RunStatement_1.RunStatement) {\n            return;\n        }\n        if (st instanceof GotoStatement_1.GotoStatement) {\n            const found = this.source.find(st.gotoLine.value);\n            if (found) {\n                this.ip = found.index;\n            }\n            else {\n                throw new Error(`source line ${st.gotoLine.value} not found`);\n            }\n            return;\n        }\n        if (st instanceof GoSubStatement_1.GoSubStatement) {\n            const found = this.source.find(st.gotoLine.value);\n            if (found) {\n                //console.log(\"gosub \",found)\n                this.ipStack.push(this.ip);\n                this.ip = found.index;\n            }\n            else {\n                throw new Error(`source line ${st.gotoLine.value} not found`);\n            }\n        }\n        if (st instanceof ReturnStatement_1.ReturnStatement) {\n            if (st.gotoLine) {\n                const found = this.source.find(st.gotoLine.value);\n                if (found) {\n                    this.ipStack.pop();\n                    this.ip = found.index;\n                }\n                else {\n                    throw new Error(`source line ${st.gotoLine.value} not found`);\n                }\n            }\n            else {\n                if (this.ipStack.length > 0) {\n                    const targetIp = this.ipStack.pop();\n                    if (targetIp !== undefined) {\n                        this.ip = targetIp + 1;\n                    }\n                    else {\n                        throw new Error(`gosub stack return undefined`);\n                    }\n                }\n                else {\n                    throw new Error(`gosub stack is empty`);\n                }\n            }\n        }\n        if (st instanceof IfStatement_1.IfStatement) {\n            const bval = this.evalExpression(st.boolExp);\n            if (bval) {\n                this.evalStatement(st.trueStatement);\n            }\n            else if (st.falseStatement) {\n                this.evalStatement(st.falseStatement);\n            }\n        }\n        if (st instanceof PrintStatement_1.PrintStatement) {\n            st.args.forEach((exp) => {\n                const v = this.evalExpression(exp);\n                this.print(v);\n            });\n            this.println();\n        }\n        if (st instanceof CallStatement_1.CallStatement) {\n            const callArgs = [];\n            st.args.forEach((exp) => {\n                const v = this.evalExpression(exp);\n                callArgs.push(v);\n            });\n            this.callProcudure(st.name.id, callArgs, st);\n        }\n    }\n    /**\n     * Проверяет есть ли еще инструкции для выполнения\n     * @returns true - есть инструкции для выполенения\n     */\n    hasNext() {\n        if (this.ip < 0)\n            return false;\n        if (this.ip >= this.source.lines.length)\n            return false;\n        return true;\n    }\n    /**\n     * Выполняет очередную инструкцию\n     * @returns true - инструкция выполнена / false - инструкция не была выполнена ибо конец\n     */\n    next() {\n        if (!this.hasNext())\n            return false;\n        const st = this.source.lines[this.ip];\n        if (st == undefined || st == null)\n            return false;\n        const beforeIp = this.ip;\n        this.evalStatement(st.statement);\n        const afterIp = this.ip;\n        if (afterIp == beforeIp) {\n            this.ip++;\n        }\n        return true;\n    }\n}\nexports.BasicVm = BasicVm;\n//# sourceMappingURL=BasicVm.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/vm/BasicVm.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/vm/ExtFun.js":
/*!*************************************************!*\
  !*** ./node_modules/ts-basic-core/vm/ExtFun.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Контекст вызова внешней функции\n */\nclass CallCtx {\n    constructor(vm, call) {\n        this.call = call;\n        this.vm = vm;\n    }\n    get source() { return this.vm.source; }\n}\nexports.CallCtx = CallCtx;\n/**\n * Внешняя функция\n */\nclass Fun {\n    /**\n     * Вызов внешней функции\n     * @param ctx контекст вызова функции\n     * @param args аргументы функции\n     */\n    apply(ctx, args) {\n    }\n}\nexports.Fun = Fun;\n/**\n * Вызов функции без аргументов\n */\nclass Fun0 extends Fun {\n    constructor(fn0) {\n        super();\n        this.fn0 = fn0;\n    }\n    apply(ctx, args) {\n        return this.fn0(ctx);\n    }\n}\nexports.Fun0 = Fun0;\n/**\n * Вызов функции без аргументов\n */\nclass Fun1 extends Fun {\n    constructor(fn1) {\n        super();\n        this.fn1 = fn1;\n    }\n    apply(ctx, args) {\n        if (args && args.length > 0) {\n            return this.fn1(ctx, args[0]);\n        }\n        else {\n            throw new Error(`can't call procedure ${name}`);\n        }\n    }\n}\nexports.Fun1 = Fun1;\n/**\n * Вызов функции без аргументов\n */\nclass Fun2 extends Fun {\n    constructor(fn2) {\n        super();\n        this.fn2 = fn2;\n    }\n    apply(ctx, args) {\n        if (args && args.length > 1) {\n            return this.fn2(ctx, args[0], args[1]);\n        }\n        else {\n            throw new Error(`can't call procedure ${name}`);\n        }\n    }\n}\nexports.Fun2 = Fun2;\n/**\n * Вызов функции без аргументов\n */\nclass Fun3 extends Fun {\n    constructor(fn3) {\n        super();\n        this.fn3 = fn3;\n    }\n    apply(ctx, args) {\n        if (args && args.length > 2) {\n            return this.fn3(ctx, args[0], args[1], args[2]);\n        }\n        else {\n            throw new Error(`can't call procedure ${name}`);\n        }\n    }\n}\nexports.Fun3 = Fun3;\n//# sourceMappingURL=ExtFun.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/vm/ExtFun.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/vm/Memo.js":
/*!***********************************************!*\
  !*** ./node_modules/ts-basic-core/vm/Memo.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Память VM\n */\nclass Memo {\n    constructor() {\n        /**\n         * Непочредственно значния\n         */\n        this.values = {};\n        /**\n         * Подписчики на изменения значений памяти VM\n         */\n        this.listeners = [];\n        /**\n         * Выводить на консоль изменения памяти\n         */\n        this.debug = false;\n        /**\n         * Игнорирование регистра символов в именах переменных\n         */\n        this.ignoreCase = true;\n    }\n    /**\n     * Чтение значения\n     * @param varname имя переменной\n     */\n    read(varname, indexes) {\n        let v = this.values[varname];\n        if (v == undefined && this.ignoreCase) {\n            const matched = Object.keys(this.values).filter((x, y, z) => {\n                return x.toUpperCase() == varname.toUpperCase();\n            });\n            if (matched.length > 0) {\n                v = this.values[matched[0]];\n            }\n        }\n        if (indexes) {\n            const arr = [];\n            for (let a of indexes) {\n                arr.push(a);\n            }\n            while (indexes.length > 0) {\n                const idx = indexes[0];\n                indexes.splice(0, 1);\n                if (v instanceof Object || v instanceof Array) {\n                    v = v[idx];\n                }\n                else {\n                    v = undefined;\n                    break;\n                }\n            }\n            if (this.debug)\n                console.log(`debug read var ${varname}[${arr}] = ${v}`);\n            return v;\n        }\n        return v;\n    }\n    emit(varname, from, to, indexes) {\n        for (let ls of this.listeners) {\n            ls(varname, from, to, indexes);\n        }\n    }\n    /**\n     * Запись значения памяти\n     * @param varname имя переменной\n     * @param value значение переменной\n     */\n    write(varname, value, indexes) {\n        const aindexes = [];\n        if (indexes) {\n            for (let a of indexes) {\n                aindexes.push(a);\n            }\n        }\n        if (indexes) {\n            let arr = [];\n            let v = this.values[varname];\n            if (v == undefined && this.ignoreCase) {\n                const matchedVarNames = Object.keys(this.values).filter((x, y, z) => {\n                    return x.toUpperCase() == varname.toUpperCase();\n                });\n                if (matchedVarNames.length > 0) {\n                    v = this.values[matchedVarNames[0]];\n                }\n            }\n            if (v instanceof Array\n                || v instanceof Object) {\n                arr = v;\n                if (this.debug)\n                    console.log(`resolved ${varname} as []`);\n            }\n            else {\n                const matchedVarNames = Object.keys(this.values).filter((x, y, z) => {\n                    return x.toUpperCase() == varname.toUpperCase();\n                });\n                matchedVarNames.forEach(mname => {\n                    if (mname != varname) {\n                        const old = this.values[mname];\n                        delete this.values[mname];\n                        this.emit(mname, old, undefined);\n                    }\n                });\n                this.values[varname] = arr;\n                if (this.debug)\n                    console.log(`assign ${varname} = []`);\n            }\n            while (indexes.length > 1) {\n                const idx = indexes[0];\n                indexes.splice(0, 1);\n                if (arr[idx] instanceof Object || arr[idx] instanceof Array) {\n                    arr = arr[idx];\n                    if (this.debug)\n                        console.log(`resolved [${idx}] as ${typeof (arr)}`);\n                }\n                else {\n                    arr[idx] = [];\n                    arr = arr[idx];\n                    if (this.debug)\n                        console.log(`assign [${idx}] = []`);\n                }\n            }\n            let old = undefined;\n            if (indexes.length == 1) {\n                const idx = indexes[0];\n                old = arr[idx];\n                arr[idx] = value;\n                if (this.debug)\n                    console.log(`assign [${idx}] = ${value}`);\n            }\n            this.emit(varname, old, value, aindexes);\n            return;\n        }\n        if (this.debug)\n            console.log(`debug write var ${varname} = ${value}`);\n        if (this.ignoreCase) {\n            const matched = Object.keys(this.values).filter((x, y, z) => {\n                return x.toUpperCase() == varname.toUpperCase();\n            });\n            matched.forEach(n => {\n                if (n != varname) {\n                    const old = this.values[n];\n                    delete this.values[n];\n                    this.emit(n, old, undefined);\n                }\n            });\n            const old = this.values[varname];\n            this.values[varname] = value;\n            this.emit(varname, old, value);\n        }\n        else {\n            const old = this.values[varname];\n            this.values[varname] = value;\n            this.emit(varname, old, value);\n        }\n    }\n    get varnames() {\n        return Object.keys(this.values);\n    }\n}\nexports.Memo = Memo;\n//# sourceMappingURL=Memo.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/vm/Memo.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/vm/Printer.js":
/*!**************************************************!*\
  !*** ./node_modules/ts-basic-core/vm/Printer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass ConsolePrinter {\n    constructor() {\n        this.args = [];\n        this.prefix = \"\";\n    }\n    clone() {\n        const c = new ConsolePrinter();\n        c.args = this.args;\n        c.prefix = this.prefix;\n        return c;\n    }\n    configure(x) {\n        x(this);\n        return this;\n    }\n    print(value) {\n        this.args.push(value);\n    }\n    println() {\n        console.log(this.prefix + this.args.map(x => \"\" + x).join(\"\"));\n        this.args = [];\n    }\n}\nexports.ConsolePrinter = ConsolePrinter;\nclass CustomPrinter {\n    constructor(printfn, printlnfn) {\n        this.printfn = printfn;\n        this.printlnfn = printlnfn;\n    }\n    clone() {\n        return new CustomPrinter(this.printfn, this.printlnfn);\n    }\n    print(value) {\n        this.printfn(value);\n    }\n    println() {\n        this.printlnfn();\n    }\n}\nexports.CustomPrinter = CustomPrinter;\nclass SingleFnPrinter {\n    constructor(printfn) {\n        this.args = [];\n        this.printfn = printfn;\n    }\n    clone() {\n        const c = new SingleFnPrinter(this.printfn);\n        this.args.forEach(x => c.args.push(x));\n        return c;\n    }\n    print(value) {\n        this.args.push(value);\n    }\n    println() {\n        this.printfn(this.args);\n        this.args = [];\n    }\n}\nexports.SingleFnPrinter = SingleFnPrinter;\nexports.printers = {\n    console: new ConsolePrinter(),\n    custom(printfn, printlnfn) {\n        return new CustomPrinter(printfn, printlnfn);\n    },\n    sprint(printfn) {\n        return new SingleFnPrinter(printfn);\n    }\n};\n//# sourceMappingURL=Printer.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/vm/Printer.js?");

/***/ }),

/***/ "./node_modules/ts-basic-core/vm/SourceUnit.js":
/*!*****************************************************!*\
  !*** ./node_modules/ts-basic-core/vm/SourceUnit.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Parser_1 = __webpack_require__(/*! ../ast/Parser */ \"./node_modules/ts-basic-core/ast/Parser.js\");\n/**\n * Исходная строка\n */\nclass SourceLine {\n    constructor(line, code) {\n        this.line = line;\n        this.statement = code;\n    }\n}\nexports.SourceLine = SourceLine;\n/**\n * Исходный текст\n */\nclass SourceUnit {\n    /**\n     * Конструктор\n     * @param sample образец для копирования\n     */\n    constructor(sample) {\n        /**\n         * Набор строк исхдного текста\n         */\n        this.sourceLines = [];\n        //#region lines : IDXSourceLine\n        this.linesCache = null;\n        if (sample) {\n            for (let li in sample.sourceLines) {\n                this.sourceLines[li] = sample.sourceLines[li];\n            }\n        }\n    }\n    /**\n     * Возвращает список исходных строк\n     */\n    get lines() {\n        if (this.linesCache)\n            return this.linesCache;\n        let lines = [];\n        let idx = -1;\n        for (let sl of this.sourceLines) {\n            idx++;\n            lines.push({ statement: sl.statement, index: idx, line: sl.line });\n        }\n        this.linesCache = Object.freeze(lines);\n        return this.linesCache;\n    }\n    //#endregion\n    /**\n     * Возвращает исходную строку (номер, строка / индекс) по ее номеру\n     * @param line номер строки\n     */\n    find(line) {\n        if (line < 0)\n            return null;\n        for (let i in this.sourceLines) {\n            let sline = this.sourceLines[i];\n            if (sline.line == line) {\n                return { statement: sline.statement, index: parseInt(i), line: sline.line };\n            }\n        }\n        return null;\n    }\n    /**\n     * Возвращает исходную строку (номер, строка / индекс) по ее номеру\n     * @param line номер строки\n     */\n    line(line) {\n        const res = this.find(line);\n        if (res)\n            return res;\n        throw new Error(`source line with number ${line} not found`);\n    }\n    /**\n     * Добавляет строку и возвращает новый объект исходного когда\n     * @param line номер строки\n     * @param code код\n     * @returns модифицированный исходный код\n     */\n    set(line, code) {\n        if (line < 0)\n            throw new Error(\"argument line(=\" + line + \") < 0\");\n        const fnd = this.find(line);\n        if (fnd) {\n            let cln = new SourceUnit(this);\n            cln.sourceLines[fnd.index] = new SourceLine(line, code);\n            return cln;\n        }\n        let cln = new SourceUnit(this);\n        cln.sourceLines.push(new SourceLine(line, code));\n        cln.sourceLines = cln.sourceLines.sort((a, b) => a.line - b.line);\n        return cln;\n    }\n    /**\n     * Удаляет строку исходного кода\n     * @param idx индекс строки\n     * @returns модифицированный исходный код\n     */\n    removeByIndex(idx) {\n        if (idx < 0)\n            throw new Error(`argument idx(=${idx})<0`);\n        if (idx >= this.sourceLines.length)\n            return this;\n        let cln = new SourceUnit(this);\n        cln.sourceLines.splice(idx, 1);\n        return cln;\n    }\n    /**\n     * Удялет строку исходного кода\n     * @param line номер строки\n     * @returns модифицированный исходный код\n     */\n    removeByLine(line) {\n        if (line < 0)\n            throw new Error(`argument line(=${line})<0`);\n        const fnd = this.find(line);\n        if (fnd) {\n            let cln = new SourceUnit(this);\n            cln.sourceLines.splice(fnd.index, 1);\n            return cln;\n        }\n        return this;\n    }\n    /**\n     * Парсинг исходного текста\n     * @param source исходный текст\n     * @param presult результат парсинга\n     */\n    parse(source, presult) {\n        if (source) {\n            const parser = Parser_1.Parser.create(source);\n            const stmts = parser.statements();\n            let res = this;\n            if (stmts) {\n                const sstmts = [];\n                const istmts = [];\n                if (presult && presult.statments) {\n                    presult.statments(stmts);\n                }\n                for (let st of stmts.statements) {\n                    if (st.sourceLine) {\n                        res = res.set(st.sourceLine, st);\n                        sstmts.push(st);\n                    }\n                    else {\n                        istmts.push(st);\n                    }\n                }\n                if (presult && presult.sources) {\n                    presult.sources(sstmts);\n                }\n                if (presult && presult.immediateStatements) {\n                    presult.immediateStatements(istmts);\n                }\n            }\n            return res;\n        }\n        return this;\n    }\n}\nexports.SourceUnit = SourceUnit;\n/**\n * Парсинг исходника\n * @param source исходник\n */\nfunction parse(source) {\n    return new SourceUnit().parse(source);\n}\nexports.parse = parse;\n//# sourceMappingURL=SourceUnit.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-core/vm/SourceUnit.js?");

/***/ }),

/***/ "./node_modules/ts-basic-stdlib/stdlib/TsLang.js":
/*!*******************************************************!*\
  !*** ./node_modules/ts-basic-stdlib/stdlib/TsLang.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ExtFun_1 = __webpack_require__(/*! ts-basic-core/vm/ExtFun */ \"./node_modules/ts-basic-core/vm/ExtFun.js\");\nfunction register(memo) {\n    memo.write('LEN', new ExtFun_1.Fun1((ctx, a) => {\n        if (a instanceof Array) {\n            return a.length;\n        }\n        else if (a instanceof String) {\n            return a.length;\n        }\n        else if (typeof (a) == 'string') {\n            return a.length;\n        }\n        //return typeof(a);\n    }));\n}\nexports.register = register;\n//# sourceMappingURL=TsLang.js.map\n\n//# sourceURL=webpack:///./node_modules/ts-basic-stdlib/stdlib/TsLang.js?");

/***/ }),

/***/ "./out/hello.js":
/*!**********************!*\
  !*** ./out/hello.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar wu = __importStar(__webpack_require__(/*! ./ui/WidgetUtil */ \"./out/ui/WidgetUtil.js\"));\n\nvar SourceUnit_1 = __webpack_require__(/*! ts-basic-core/vm/SourceUnit */ \"./node_modules/ts-basic-core/vm/SourceUnit.js\");\n\nvar AstToBasic_1 = __webpack_require__(/*! ts-basic-core/ast/AstToBasic */ \"./node_modules/ts-basic-core/ast/AstToBasic.js\");\n\nvar Memo_1 = __webpack_require__(/*! ts-basic-core/vm/Memo */ \"./node_modules/ts-basic-core/vm/Memo.js\");\n\nvar BasicVm_1 = __webpack_require__(/*! ts-basic-core/vm/BasicVm */ \"./node_modules/ts-basic-core/vm/BasicVm.js\");\n\nvar Printer_1 = __webpack_require__(/*! ts-basic-core/vm/Printer */ \"./node_modules/ts-basic-core/vm/Printer.js\");\n\nvar tsLang = __importStar(__webpack_require__(/*! ts-basic-stdlib/stdlib/TsLang */ \"./node_modules/ts-basic-stdlib/stdlib/TsLang.js\"));\n\nvar ExtFun_1 = __webpack_require__(/*! ts-basic-core/vm/ExtFun */ \"./node_modules/ts-basic-core/vm/ExtFun.js\");\n\nvar GWBASICApp =\n/*#__PURE__*/\nfunction () {\n  function GWBASICApp() {\n    _classCallCheck(this, GWBASICApp);\n\n    //#endregion\n    //#region sourceUnit\n    this.suValue = new SourceUnit_1.SourceUnit();\n    this.renderedSourceLines = {};\n    this.uiVars = {};\n  } //#region ui\n\n\n  _createClass(GWBASICApp, [{\n    key: \"parseBasic\",\n    value: function parseBasic(command) {\n      try {\n        var imStmts = [];\n        this.sourceUnit = this.sourceUnit.parse(command, {\n          immediateStatements: function immediateStatements(statements) {\n            imStmts = statements;\n          }\n        });\n        this.rebuildVm();\n\n        if (this.ui.parseError) {\n          this.ui.parseError.innerHTML = '';\n          this.ui.parseError.style.display = 'none';\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = imStmts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var imSt = _step.value;\n            this.vm.evalStatement(imSt);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } catch (err) {\n        if (this.ui.parseError) {\n          this.ui.parseError.textContent = err.toString();\n          this.ui.parseError.style.display = '';\n          console.log('log parse error:', err.toString());\n        } else {\n          console.log('log parse error:', err.toString());\n        }\n      }\n    }\n  }, {\n    key: \"renderSourceUnit\",\n    value: function renderSourceUnit() {\n      var _this = this;\n\n      this.renderedSourceLines = {};\n\n      if (this.ui.sourceUnit) {\n        var ui = this.ui.sourceUnit;\n        ui.innerHTML = '';\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          var _loop = function _loop() {\n            var line = _step2.value;\n            var ldiv = wu.div({\n              \"class\": \"sourceLine l\".concat(line.line, \" li\").concat(line.index)\n            }).append(ui).el;\n            wu.span({\n              \"class\": \"lineNum\"\n            }).text(line.line.toString()).append(ldiv);\n            wu.span({\n              \"class\": 'code'\n            }).text(AstToBasic_1.astToBasic(line.statement, {\n              sourceLineNumber: false\n            })).append(ldiv);\n            wu.a({\n              \"class\": 'goto act',\n              href: '#'\n            }).text('goto').append(ldiv).onclick(function (e) {\n              _this[\"goto\"](line.index);\n            });\n            wu.a({\n              \"class\": 'edit act',\n              href: '#'\n            }).text('edit').append(ldiv).onclick(function (e) {\n              if (_this.ui.sourceCode) {\n                _this.ui.sourceCode.value = AstToBasic_1.astToBasic(line.statement);\n              }\n            });\n            wu.a({\n              \"class\": 'del act',\n              href: '#'\n            }).text('del').append(ldiv).onclick(function (e) {\n              _this.sourceUnit = _this.sourceUnit.removeByIndex(line.index);\n            });\n            _this.renderedSourceLines[line.index] = ldiv;\n\n            if (_this.vm.ip == line.index) {\n              ldiv.classList.add('active');\n            }\n          };\n\n          for (var _iterator2 = this.sourceUnit.lines[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            _loop();\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n              _iterator2[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"registerLibs\",\n    value: function registerLibs() {\n      if (this.memoInstance) {\n        tsLang.register(this.memoInstance);\n      }\n    }\n  }, {\n    key: \"renderMemo\",\n    value: function renderMemo() {\n      var _this2 = this;\n\n      Object.keys(this.uiVars).forEach(function (n) {\n        delete _this2.uiVars[n];\n      });\n\n      if (this.ui.memoDump) {\n        this.ui.memoDump.innerHTML = '';\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.memo.varnames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var varname = _step3.value;\n            var varvalue = this.memo.read(varname);\n            var ui = this.renderVarValue(varname, varvalue);\n            ui.container.appendChild(ui.name);\n            ui.container.appendChild(ui.value);\n            this.uiVars[varname] = ui;\n            this.ui.memoDump.appendChild(ui.container);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n              _iterator3[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"renderMemoVar\",\n    value: function renderMemoVar(varname, oldvalue, newvalue) {\n      if (newvalue != undefined) {\n        var ui = this.uiVars[varname];\n\n        if (ui) {\n          ui.value.innerText = newvalue;\n        } else {\n          ui = this.renderVarValue(varname, newvalue);\n          ui.container.appendChild(ui.name);\n          ui.container.appendChild(ui.value);\n          this.uiVars[varname] = ui;\n\n          if (this.ui.memoDump) {\n            this.ui.memoDump.appendChild(ui.container);\n          }\n        }\n      } else {\n        var _ui = this.uiVars[varname];\n\n        if (this.ui.memoDump && _ui) {\n          this.ui.memoDump.removeChild(_ui.container);\n          delete this.uiVars[varname];\n        }\n      }\n    }\n  }, {\n    key: \"renderVarValue\",\n    value: function renderVarValue(varname, varvalue) {\n      var clss = \"\";\n\n      var renderFn = function renderFn(value) {\n        return wu.span({\n          \"class\": 'value' + clss\n        }).text(\"Function\").el;\n      };\n\n      var render = function render(value) {\n        return wu.span({\n          \"class\": 'value' + clss\n        }).text(value).el;\n      };\n\n      if (varvalue instanceof ExtFun_1.Fun) {\n        clss += \" Fun\";\n        render = renderFn;\n      }\n\n      return {\n        container: wu.div({\n          \"class\": 'var' + clss\n        }).el,\n        name: wu.span({\n          \"class\": 'name' + clss\n        }).text(varname).el,\n        value: render(varvalue)\n      };\n    } //#endregion\n    //#region vm\n\n  }, {\n    key: \"rebuildVm\",\n    value: function rebuildVm() {\n      var _this3 = this;\n\n      this.vmInstance = new BasicVm_1.BasicVm(this.sourceUnit, this.memo);\n      this.vmInstance.printer = this.vmPrinter;\n      setTimeout(function () {\n        _this3.renderVm();\n      }, 1);\n      return this.vmInstance;\n    }\n  }, {\n    key: \"renderVm\",\n    value: function renderVm() {\n      this.renderIp();\n    } //#endregion\n    //#region goto/renderIp\n\n  }, {\n    key: \"goto\",\n    value: function goto(ip) {\n      var _this4 = this;\n\n      console.log(\"goto ip=\".concat(ip));\n      this.vm.ip = ip;\n      setTimeout(function () {\n        _this4.renderIp();\n      }, 1);\n    }\n  }, {\n    key: \"renderIp\",\n    value: function renderIp() {\n      for (var i = 0; i < Object.getOwnPropertyNames(this.renderedSourceLines).length; i++) {\n        this.renderedSourceLines[i].classList.remove('active');\n      }\n\n      var lineDiv = this.renderedSourceLines[this.vm.ip];\n\n      if (lineDiv) {\n        lineDiv.classList.add('active');\n      }\n    } //#endregion\n    //#region goNext\n\n  }, {\n    key: \"goNext\",\n    value: function goNext() {\n      console.log('goNext() clicked');\n\n      if (this.vm.hasNext()) {\n        this.vm.next();\n        this.renderIp();\n      }\n    } //#endregion\n\n  }, {\n    key: \"init\",\n    value: function init() {\n      var _this5 = this;\n\n      if (this.ui.parseSourceCode && this.ui.sourceCode) {\n        var btn = this.ui.parseSourceCode;\n        var txt = this.ui.sourceCode;\n        btn.addEventListener('click', function (e) {\n          return _this5.parseBasic(txt.value);\n        });\n        txt.addEventListener('keydown', function (e) {\n          if (e.keyCode == 13 && e.ctrlKey) {\n            _this5.parseBasic(txt.value);\n          } else if (e.code == 'KeyN' && e.altKey) {\n            _this5.goNext();\n          } else {//console.log('keydown',e)\n          }\n        });\n      }\n\n      if (this.ui.goNext) {\n        this.ui.goNext.addEventListener('click', function (e) {\n          return _this5.goNext();\n        });\n      }\n\n      this.memo.listeners.push(function (varname, from, to) {\n        console.log('handled var changes ', varname, from, to);\n\n        _this5.renderMemoVar(varname, from, to);\n      });\n\n      if (this.ui.showHelp) {\n        this.ui.showHelp.addEventListener('click', function (e) {\n          if (_this5.ui.helpContent) {\n            _this5.ui.helpContent.classList.add('active');\n\n            console.log(\"clicked 1\");\n          }\n        });\n      }\n\n      if (this.ui.closeHelp) {\n        this.ui.closeHelp.addEventListener('click', function (e) {\n          if (_this5.ui.helpContent) {\n            _this5.ui.helpContent.classList.remove('active');\n\n            console.log(\"clicked 2\");\n          }\n        });\n      }\n\n      if (this.ui.clearOutput) {\n        this.ui.clearOutput.addEventListener('click', function (e) {\n          if (_this5.ui.output) {\n            _this5.ui.output.innerHTML = \"\";\n          }\n        });\n      }\n    }\n  }, {\n    key: \"ui\",\n    get: function get() {\n      return {\n        get sourceUnit() {\n          return document.querySelector('#sourceUnit');\n        },\n\n        get sourceCode() {\n          return document.querySelector('#sourceCode');\n        },\n\n        get parseSourceCode() {\n          return document.querySelector('#parseSourceCode');\n        },\n\n        get parseError() {\n          return document.querySelector('#parseError');\n        },\n\n        get goNext() {\n          return document.querySelector('#goNext');\n        },\n\n        get memoDump() {\n          return document.querySelector('#memoDump');\n        },\n\n        get helpContent() {\n          return document.querySelector('#helpContent');\n        },\n\n        get showHelp() {\n          return document.querySelector('#showHelp');\n        },\n\n        get closeHelp() {\n          return document.querySelector('#closeHelp');\n        },\n\n        get output() {\n          return document.querySelector('#output');\n        },\n\n        get clearOutput() {\n          return document.querySelector('#clearOutput');\n        }\n\n      };\n    }\n  }, {\n    key: \"sourceUnit\",\n    get: function get() {\n      return this.suValue;\n    },\n    set: function set(su) {\n      var _this6 = this;\n\n      this.suValue = su;\n      setTimeout(function () {\n        _this6.renderSourceUnit();\n      }, 1);\n    }\n  }, {\n    key: \"memo\",\n    get: function get() {\n      var _this7 = this;\n\n      if (this.memoInstance) {\n        return this.memoInstance;\n      }\n\n      this.memoInstance = new Memo_1.Memo();\n      this.registerLibs();\n      setTimeout(function () {\n        _this7.renderMemo();\n      }, 1);\n      return this.memoInstance;\n    },\n    set: function set(mem) {\n      var _this8 = this;\n\n      this.memoInstance = mem;\n      this.registerLibs();\n      setTimeout(function () {\n        _this8.renderMemo();\n      }, 1);\n    }\n  }, {\n    key: \"vmPrinter\",\n    get: function get() {\n      var _this9 = this;\n\n      if (this.ui.output) {\n        return Printer_1.printers.sprint(function (args) {\n          var txt = args.map(function (x) {\n            return \"\" + x;\n          }).join(\"\");\n          _this9.ui.output.innerHTML += wu.toHtml(txt) + \"<br/>\";\n        });\n      } else {\n        return Printer_1.printers.console.clone().configure(function (c) {\n          c.prefix = \"BASIC> \";\n        });\n      }\n    }\n  }, {\n    key: \"vm\",\n    get: function get() {\n      var _this10 = this;\n\n      if (this.vmInstance) return this.vmInstance;\n      this.vmInstance = new BasicVm_1.BasicVm(this.sourceUnit, this.memo);\n      this.vmInstance.printer = this.vmPrinter;\n      setTimeout(function () {\n        _this10.renderVm();\n      }, 1);\n      return this.vmInstance;\n    },\n    set: function set(v) {\n      var _this11 = this;\n\n      this.vmInstance = v;\n      setTimeout(function () {\n        _this11.renderVm();\n      }, 1);\n    }\n  }]);\n\n  return GWBASICApp;\n}();\n\nnew GWBASICApp().init();\n\n//# sourceURL=webpack:///./out/hello.js?");

/***/ }),

/***/ "./out/ui/WidgetUtil.js":
/*!******************************!*\
  !*** ./out/ui/WidgetUtil.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar HtmlElementBuilder =\n/*#__PURE__*/\nfunction () {\n  function HtmlElementBuilder(el) {\n    _classCallCheck(this, HtmlElementBuilder);\n\n    this.el = el;\n  }\n\n  _createClass(HtmlElementBuilder, [{\n    key: \"append\",\n    value: function append(prnt) {\n      if (prnt) {\n        prnt.appendChild(this.el);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"html\",\n    value: function html(v) {\n      this.el.innerHTML = v;\n      return this;\n    }\n  }, {\n    key: \"text\",\n    value: function text(v) {\n      this.el.textContent = v;\n      return this;\n    }\n  }, {\n    key: \"attr\",\n    value: function attr(name, val) {\n      this.el.setAttribute(name, val);\n      return this;\n    }\n  }, {\n    key: \"onclick\",\n    value: function onclick(listener) {\n      this.el.addEventListener(\"click\", function (ev) {\n        listener(ev);\n        return null;\n      });\n      return this;\n    }\n  }]);\n\n  return HtmlElementBuilder;\n}();\n\nexports.HtmlElementBuilder = HtmlElementBuilder;\n\nfunction el(tagname, attribs) {\n  var el = document.createElement(tagname);\n\n  if (attribs) {\n    for (var k in attribs) {\n      var v = attribs[k];\n\n      if (typeof v == 'string') {\n        el.setAttribute(k, v);\n      } else if (typeof v == 'number') {\n        el.setAttribute(k, '' + v);\n      } else if (typeof v == 'boolean') {\n        el.setAttribute(k, v ? 'true' : 'false');\n      }\n    }\n  }\n\n  return new HtmlElementBuilder(el);\n}\n\nexports.el = el;\n\nfunction div(attribs) {\n  return el('div', attribs);\n}\n\nexports.div = div;\n\nfunction span(attribs) {\n  return el('span', attribs);\n}\n\nexports.span = span;\n\nfunction input(attribs) {\n  return el('input', attribs);\n}\n\nexports.input = input;\n\nfunction textInput(attribs) {\n  return el('input', attribs).attr('type', 'text');\n}\n\nexports.textInput = textInput;\n\nfunction textArea(attribs) {\n  return el('textarea', attribs);\n}\n\nexports.textArea = textArea;\n\nfunction button(attribs) {\n  return el('button', attribs);\n}\n\nexports.button = button;\n\nfunction a(attribs) {\n  return el('a', attribs);\n}\n\nexports.a = a;\n\nfunction toHtml(text) {\n  var map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  };\n  return text.replace(/[&<>\"']/g, function (m) {\n    var n = map[m];\n    return n;\n  });\n}\n\nexports.toHtml = toHtml; //createEL( 'aa', {a:1,b:2} )\n\n//# sourceURL=webpack:///./out/ui/WidgetUtil.js?");

/***/ })

/******/ });