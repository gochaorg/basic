/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./out/ts/hello.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./out/ts/Num.js":
/*!***********************!*\
  !*** ./out/ts/Num.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Возвращает целое число\n * @param n число\n */\n\nfunction asInt(n) {\n  return n | 0;\n}\n\nexports.asInt = asInt;\n\n//# sourceURL=webpack:///./out/ts/Num.js?");

/***/ }),

/***/ "./out/ts/TreeIt.js":
/*!**************************!*\
  !*** ./out/ts/TreeIt.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Шаг очередной итерации\n */\n\nvar TreeStep =\n/** @class */\nfunction () {\n  /**\n   * Конструктор\n   * @param value Значение узла дерева\n   * @param parent Ссылка на родительский элемент дерева\n   */\n  function TreeStep(value, parent) {\n    this.value = value;\n    this.parent = parent;\n  }\n  /**\n   * Создание дочернего пути/шага при обходе дерева\n   * @param value дочернее значение узла\n   */\n\n\n  TreeStep.prototype.follow = function (value) {\n    return new TreeStep(value, this);\n  };\n\n  Object.defineProperty(TreeStep.prototype, \"path\", {\n    /**\n     * Возвращает путь значений в дереве\n     */\n    get: function get() {\n      var res = [];\n      var ts = this;\n\n      while (ts != undefined && ts != null) {\n        res.push(ts.value);\n        ts = ts.parent;\n      }\n\n      res.reverse();\n      return res;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return TreeStep;\n}();\n\nexports.TreeStep = TreeStep;\n/**\n * Итератор для обхода дерева\n */\n\nvar TreeIt =\n/** @class */\nfunction () {\n  /**\n   * Конструктор\n   * @param start начальный узел дерева\n   * @param follow функция перехода к дочерним узлам\n   */\n  function TreeIt(start, follow) {\n    this.follow = follow;\n    this.current = [new TreeStep(start)];\n  }\n  /**\n   * Проверяет наличие дочернего узла\n   */\n\n\n  TreeIt.prototype.hasNext = function () {\n    return this.current.length > 0;\n  };\n  /**\n   * Переход к следующему узлу в дереве\n   */\n\n\n  TreeIt.prototype.fetch = function () {\n    var _this = this;\n\n    if (this.current.length <= 0) return undefined;\n    var res = this.current.splice(0, 1); //let res:T|undefined = this.current.pop()\n\n    if (res != undefined) {\n      res.forEach(function (r) {\n        _this.follow(r.value).forEach(function (n) {\n          return _this.current.push(r.follow(n));\n        });\n      });\n    }\n\n    if (res != undefined) {\n      return res.length > 0 ? res[0] : undefined;\n    }\n\n    return undefined;\n  };\n  /**\n   * Обход узлов дерева\n   * @param start начальный узел дерева\n   * @param follow функция перехода к дочерним узлам\n   * @param consumer функция - визер узлов дерева\n   */\n\n\n  TreeIt.each = function (start, follow, consumer) {\n    if (start == null || start == undefined) throw new Error(\"illegal arg start\");\n    if (follow == null || follow == undefined) throw new Error(\"illegal arg follow\");\n    if (consumer == null || consumer == undefined) throw new Error(\"illegal arg consumer\");\n    var titer = new TreeIt(start, follow);\n\n    while (titer.hasNext()) {\n      var f = titer.fetch();\n\n      if (f) {\n        consumer(f);\n      }\n    }\n  };\n  /**\n   * Разворчивание дерева в список\n   * @param start начальный узел\n   * @param follow функция перехода к дочерним узлам\n   */\n\n\n  TreeIt.list = function (start, follow) {\n    if (start == null || start == undefined) throw new Error(\"illegal arg start\");\n    if (follow == null || follow == undefined) throw new Error(\"illegal arg follow\");\n    var arr = [];\n    TreeIt.each(start, follow, function (n) {\n      arr.push(n);\n    });\n    return arr;\n  };\n\n  return TreeIt;\n}();\n\nexports.TreeIt = TreeIt;\n\n//# sourceURL=webpack:///./out/ts/TreeIt.js?");

/***/ }),

/***/ "./out/ts/WidgetUtil.js":
/*!******************************!*\
  !*** ./out/ts/WidgetUtil.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar HtmlElementBuilder =\n/** @class */\nfunction () {\n  function HtmlElementBuilder(el) {\n    this.el = el;\n  }\n\n  HtmlElementBuilder.prototype.append = function (prnt) {\n    if (prnt) {\n      prnt.appendChild(this.el);\n    }\n\n    return this;\n  };\n\n  HtmlElementBuilder.prototype.html = function (v) {\n    this.el.innerHTML = v;\n    return this;\n  };\n\n  HtmlElementBuilder.prototype.text = function (v) {\n    this.el.textContent = v;\n    return this;\n  };\n\n  HtmlElementBuilder.prototype.attr = function (name, val) {\n    this.el.setAttribute(name, val);\n    return this;\n  };\n\n  HtmlElementBuilder.prototype.onclick = function (listener) {\n    this.el.addEventListener(\"click\", function (ev) {\n      listener(ev);\n      return null;\n    });\n    return this;\n  };\n\n  return HtmlElementBuilder;\n}();\n\nexports.HtmlElementBuilder = HtmlElementBuilder;\n\nfunction el(tagname, attribs) {\n  var el = document.createElement(tagname);\n\n  if (attribs) {\n    for (var k in attribs) {\n      var v = attribs[k];\n\n      if (typeof v == 'string') {\n        el.setAttribute(k, v);\n      } else if (typeof v == 'number') {\n        el.setAttribute(k, '' + v);\n      } else if (typeof v == 'boolean') {\n        el.setAttribute(k, v ? 'true' : 'false');\n      }\n    }\n  }\n\n  return new HtmlElementBuilder(el);\n}\n\nexports.el = el;\n\nfunction div(attribs) {\n  return el('div', attribs);\n}\n\nexports.div = div;\n\nfunction span(attribs) {\n  return el('span', attribs);\n}\n\nexports.span = span;\n\nfunction input(attribs) {\n  return el('input', attribs);\n}\n\nexports.input = input;\n\nfunction textInput(attribs) {\n  return el('input', attribs).attr('type', 'text');\n}\n\nexports.textInput = textInput;\n\nfunction textArea(attribs) {\n  return el('textarea', attribs);\n}\n\nexports.textArea = textArea;\n\nfunction button(attribs) {\n  return el('button', attribs);\n}\n\nexports.button = button;\n\nfunction a(attribs) {\n  return el('a', attribs);\n}\n\nexports.a = a; //createEL( 'aa', {a:1,b:2} )\n\n//# sourceURL=webpack:///./out/ts/WidgetUtil.js?");

/***/ }),

/***/ "./out/ts/ast/AstToBasic.js":
/*!**********************************!*\
  !*** ./out/ts/ast/AstToBasic.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar OperatorExp_1 = __webpack_require__(/*! ./OperatorExp */ \"./out/ts/ast/OperatorExp.js\");\n\nvar LetStatement_1 = __webpack_require__(/*! ./LetStatement */ \"./out/ts/ast/LetStatement.js\");\n\nvar RemStatement_1 = __webpack_require__(/*! ./RemStatement */ \"./out/ts/ast/RemStatement.js\");\n\nvar RunStatement_1 = __webpack_require__(/*! ./RunStatement */ \"./out/ts/ast/RunStatement.js\");\n\nvar Statements_1 = __webpack_require__(/*! ./Statements */ \"./out/ts/ast/Statements.js\");\n\nvar SourceUnit_1 = __webpack_require__(/*! ../vm/SourceUnit */ \"./out/ts/vm/SourceUnit.js\");\n\nvar GotoStatement_1 = __webpack_require__(/*! ./GotoStatement */ \"./out/ts/ast/GotoStatement.js\");\n\nvar IfStatement_1 = __webpack_require__(/*! ./IfStatement */ \"./out/ts/ast/IfStatement.js\");\n\nvar GoSubStatement_1 = __webpack_require__(/*! ./GoSubStatement */ \"./out/ts/ast/GoSubStatement.js\");\n\nvar ReturnStatement_1 = __webpack_require__(/*! ./ReturnStatement */ \"./out/ts/ast/ReturnStatement.js\");\n\nvar PrintStatement_1 = __webpack_require__(/*! ./PrintStatement */ \"./out/ts/ast/PrintStatement.js\");\n/**\n * Генератор из AST в BASIC\n */\n\n\nfunction astToBasic(root, opts) {\n  if (opts == undefined) {\n    opts = {\n      sourceLineNumber: true\n    };\n  }\n\n  if (root == undefined) return \"\";\n  if (root == null) return \"\"; //#region LiteralExpression\n\n  if (root instanceof OperatorExp_1.LiteralExpression) {\n    if (typeof root.value == 'number') {\n      return '' + root.value;\n    } else if (typeof root.value == 'boolean') {\n      if (root.value) {\n        return '1<2';\n      } else {\n        return '1>2';\n      }\n    } else if (typeof root.value == 'string') {\n      var sval = root.value;\n      var str = \"\\\"\";\n\n      for (var i = 0; i < sval.length; i++) {\n        var ch = str[i];\n\n        if (ch == '\"') {\n          str += \"encode_dquote\";\n        } else if (ch == \"'\") {\n          str += \"encode_quote\";\n        } else if (ch == \"\\n\") {\n          str += \"encode_nl\";\n        } else if (ch == \"\\r\") {\n          str += \"encode_cr\";\n        } else if (ch == \"\\t\") {\n          str += \"encode_tab\";\n        } else if (ch.charCodeAt(0) > 31) {\n          str += ch;\n        }\n      }\n\n      str += \"\\\"\";\n      return str;\n    } else {\n      throw new Error(\"unknow Literal value type = \" + _typeof(root.value));\n    }\n  } //#endregion\n  //#region var ref\n\n\n  if (root instanceof OperatorExp_1.VarArrIndexRef) {\n    var code = '';\n    code += root.varname;\n    code += '(';\n    var idx = -1;\n\n    for (var _i = 0, _a = root.indexes; _i < _a.length; _i++) {\n      var aidx = _a[_i];\n      idx++;\n      if (idx > 0) code += ',';\n      code += astToBasic(aidx, opts);\n    }\n\n    code += ')';\n    return code;\n  } //#endregion\n  //#region var ref\n\n\n  if (root instanceof OperatorExp_1.VarRefExpression) {\n    return root.varname;\n  } //#endregion\n  //#region unary ref\n\n\n  if (root instanceof OperatorExp_1.UnaryOpExpression) {\n    return root.operator.keyWord + '(' + astToBasic(root.base, opts) + ')';\n  } //#endregion\n  //#region BinaryOpExpression\n\n\n  if (root instanceof OperatorExp_1.BinaryOpExpression) {\n    var code = '';\n\n    if (root.left.treeSize > 1) {\n      code += '(' + astToBasic(root.left, opts) + ')';\n    } else {\n      code += astToBasic(root.left, opts);\n    }\n\n    code += root.operator.keyWord;\n\n    if (root.right.treeSize > 1) {\n      code += '(' + astToBasic(root.right, opts) + ')';\n    } else {\n      code += astToBasic(root.right, opts);\n    }\n\n    return code;\n  } //#endregion\n  //#region LET\n\n\n  if (root instanceof LetStatement_1.LetStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"LET \" + root.varname + \" = \" + astToBasic(root.value, opts);\n    return code;\n  } //#endregion\n  //#region REM\n\n\n  if (root instanceof RemStatement_1.RemStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"REM \" + root.rem.comment;\n    return code;\n  } //#endregion\n  //#region RUN\n\n\n  if (root instanceof RunStatement_1.RunStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"RUN\";\n\n    if (root.runLine != undefined) {\n      code += \" \" + root.runLine;\n    }\n\n    return code;\n  } //#endregion\n  //#region GOTO\n\n\n  if (root instanceof GotoStatement_1.GotoStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"GOTO\";\n\n    if (root.gotoLine != undefined) {\n      code += \" \" + root.gotoLine.value;\n    }\n\n    return code;\n  } //#endregion\n  //#region GOSUB\n\n\n  if (root instanceof GoSubStatement_1.GoSubStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"GOSUB\";\n\n    if (root.gotoLine != undefined) {\n      code += \" \" + root.gotoLine.value;\n    }\n\n    return code;\n  } //#endregion\n  //#region RETURN\n\n\n  if (root instanceof ReturnStatement_1.ReturnStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"RETURN\";\n\n    if (root.gotoLine != undefined) {\n      code += \" \" + root.gotoLine.value;\n    }\n\n    return code;\n  } //#endregion\n  //#region IF\n\n\n  if (root instanceof IfStatement_1.IfStatement) {\n    var code = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code = root.sourceLine + \" \";\n    }\n\n    code += \"IF \";\n    code += astToBasic(root.boolExp, opts);\n    code += \" THEN \";\n    code += astToBasic(root.trueStatement, {\n      sourceLineNumber: false\n    });\n\n    if (root.falseStatement) {\n      code += \" ELSE \";\n      code += astToBasic(root.falseStatement, {\n        sourceLineNumber: false\n      });\n    }\n\n    return code;\n  } //#endregion\n  //#region PrintStatement\n\n\n  if (root instanceof PrintStatement_1.PrintStatement) {\n    var code_1 = '';\n\n    if (root.sourceLine != undefined && opts.sourceLineNumber) {\n      code_1 = root.sourceLine + \" \";\n    }\n\n    code_1 += \"PRINT\";\n    if (root.args.length > 0) code_1 += \" \";\n    var argi_1 = -1;\n    root.args.forEach(function (arg) {\n      argi_1++;\n\n      if (argi_1 > 0) {\n        code_1 += \",\";\n      }\n\n      code_1 += astToBasic(arg, opts);\n    });\n    return code_1;\n  } //#endregion\n  //#region Statements\n\n\n  if (root instanceof Statements_1.Statements) {\n    var code_2 = '';\n    root.statements.forEach(function (st) {\n      if (code_2.length > 0) {\n        code_2 += \"\\n\";\n      }\n\n      code_2 += astToBasic(st, opts);\n    });\n    return code_2;\n  } //#endregion\n  //#region SourceUnit\n\n\n  if (root instanceof SourceUnit_1.SourceUnit) {\n    var code_3 = '';\n    root.lines.forEach(function (line) {\n      if (code_3.length > 0) {\n        code_3 += \"\\n\";\n      }\n\n      code_3 += astToBasic(line.statement, opts);\n    });\n    return code_3;\n  } //#endregion\n\n\n  throw new Error(\"unknow argument type \" + root + \":\" + Object.getPrototypeOf(root));\n}\n\nexports.astToBasic = astToBasic;\n\n//# sourceURL=webpack:///./out/ts/ast/AstToBasic.js?");

/***/ }),

/***/ "./out/ts/ast/GoSubStatement.js":
/*!**************************************!*\
  !*** ./out/ts/ast/GoSubStatement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar GoSubStatement =\n/** @class */\nfunction (_super) {\n  __extends(GoSubStatement, _super);\n\n  function GoSubStatement(begin, end, line) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.gotoLine = line;\n    _this.kind = 'Gosub';\n    return _this;\n  }\n\n  return GoSubStatement;\n}(Statement_1.Statement);\n\nexports.GoSubStatement = GoSubStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/GoSubStatement.js?");

/***/ }),

/***/ "./out/ts/ast/GotoStatement.js":
/*!*************************************!*\
  !*** ./out/ts/ast/GotoStatement.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar GotoStatement =\n/** @class */\nfunction (_super) {\n  __extends(GotoStatement, _super);\n\n  function GotoStatement(begin, end, line) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.gotoLine = line;\n    _this.kind = 'Goto';\n    return _this;\n  }\n\n  return GotoStatement;\n}(Statement_1.Statement);\n\nexports.GotoStatement = GotoStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/GotoStatement.js?");

/***/ }),

/***/ "./out/ts/ast/IfStatement.js":
/*!***********************************!*\
  !*** ./out/ts/ast/IfStatement.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar IfStatement =\n/** @class */\nfunction (_super) {\n  __extends(IfStatement, _super);\n\n  function IfStatement(begin, end, boolExp, trueStatement, falseStatement) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.boolExp = boolExp;\n    _this.trueStatement = trueStatement;\n    _this.falseStatement = falseStatement;\n    _this.kind = 'If';\n    return _this;\n  }\n\n  return IfStatement;\n}(Statement_1.Statement);\n\nexports.IfStatement = IfStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/IfStatement.js?");

/***/ }),

/***/ "./out/ts/ast/LetStatement.js":
/*!************************************!*\
  !*** ./out/ts/ast/LetStatement.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar LetStatement =\n/** @class */\nfunction (_super) {\n  __extends(LetStatement, _super);\n\n  function LetStatement(begin, end, variable, value) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.variable = variable;\n    _this.value = value;\n    _this.kind = 'Let';\n    return _this;\n  }\n\n  Object.defineProperty(LetStatement.prototype, \"varname\", {\n    get: function get() {\n      return this.variable.id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LetStatement;\n}(Statement_1.Statement);\n\nexports.LetStatement = LetStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/LetStatement.js?");

/***/ }),

/***/ "./out/ts/ast/Lexer.js":
/*!*****************************!*\
  !*** ./out/ts/ast/Lexer.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Работа с лексемами BASIC\n */\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Абстрактная поддержка лексем\n */\n\nvar AbstractLex =\n/** @class */\nfunction () {\n  function AbstractLex(begin, end) {\n    if (begin !== undefined) {\n      this.begin = begin;\n    } else {\n      this.begin = 0;\n    }\n\n    if (end !== undefined) {\n      this.end = end;\n    } else {\n      this.end = 0;\n    }\n  }\n\n  return AbstractLex;\n}();\n\nexports.AbstractLex = AbstractLex;\n/**\n * Получение списка лексем из текста\n * @param text текст\n * @param lexs парсеры лексем\n */\n\nfunction lexems(text, lexs) {\n  var res = [];\n  var off = 0;\n\n  while (true) {\n    if (off >= text.length) break;\n    var lx = null;\n\n    for (var _i = 0, lexs_1 = lexs; _i < lexs_1.length; _i++) {\n      var lxParse = lexs_1[_i];\n      if (lx != null) break;\n      lx = lxParse(text, off);\n\n      if (lx != null) {\n        if (lx.end <= off) throw new Error(\"fail lexem parse, end(=\" + lx.end + \") < off(=\" + off + \")\");\n        res.push(lx);\n        off = lx.end;\n        break;\n      }\n    }\n\n    if (lx == null) throw new Error(\"can't parse \" + text.substring(off, off + 50));\n  }\n\n  return res;\n}\n\nexports.lexems = lexems;\n/**\n * Поддержка разных классов символов\n */\n\nvar Chars =\n/** @class */\nfunction () {\n  function Chars() {}\n\n  Chars.isWS = function (str) {\n    if (str == ' ') return true;\n    if (str == '\\n') return true;\n    if (str == '\\r') return true;\n    if (str == '\\t') return true;\n    return false;\n  };\n\n  Chars.isNewline = function (str) {\n    if (str == '\\n') return true;\n    if (str == '\\r') return true;\n    if (str == '\\n\\r') return true;\n    if (str == '\\r\\n') return true;\n    return false;\n  };\n\n  Chars.isHexDigit = function (str) {\n    if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4') return true;\n    if (str == '5' || str == '6' || str == '7' || str == '8' || str == '9') return true;\n    if (str == 'A' || str == 'B' || str == 'C') return true;\n    if (str == 'D' || str == 'E' || str == 'F') return true;\n    if (str == 'a' || str == 'b' || str == 'c') return true;\n    if (str == 'd' || str == 'e' || str == 'f') return true;\n    return false;\n  };\n\n  Chars.hexDigit = function (str) {\n    if (!Chars.isHexDigit(str)) throw new Error(\"not a digit\");\n    if (str == '0') return 0;\n    if (str == '1') return 1;\n    if (str == '2') return 2;\n    if (str == '3') return 3;\n    if (str == '4') return 4;\n    if (str == '5') return 5;\n    if (str == '6') return 6;\n    if (str == '7') return 7;\n    if (str == '8') return 8;\n    if (str == '9') return 9;\n    if (str == 'a' || str == 'A') return 10;\n    if (str == 'b' || str == 'B') return 11;\n    if (str == 'c' || str == 'C') return 12;\n    if (str == 'd' || str == 'D') return 13;\n    if (str == 'e' || str == 'E') return 14;\n    if (str == 'f' || str == 'F') return 15;\n    throw new Error(\"not a digit\");\n  };\n\n  Chars.isDecDigit = function (str) {\n    if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4') return true;\n    if (str == '5' || str == '6' || str == '7' || str == '8' || str == '9') return true;\n    return false;\n  };\n\n  Chars.decDigit = function (str) {\n    if (!Chars.isDecDigit(str)) throw new Error(\"not a digit\");\n    if (str == '0') return 0;\n    if (str == '1') return 1;\n    if (str == '2') return 2;\n    if (str == '3') return 3;\n    if (str == '4') return 4;\n    if (str == '5') return 5;\n    if (str == '6') return 6;\n    if (str == '7') return 7;\n    if (str == '8') return 8;\n    if (str == '9') return 9;\n    throw new Error(\"not a digit\");\n  };\n\n  Chars.isOctDigit = function (str) {\n    if (str == '0' || str == '1' || str == '2' || str == '3' || str == '4') return true;\n    if (str == '5' || str == '6' || str == '7') return true;\n    return false;\n  };\n\n  Chars.octDigit = function (str) {\n    if (!Chars.isOctDigit(str)) throw new Error(\"not a digit\");\n    if (str == '0') return 0;\n    if (str == '1') return 1;\n    if (str == '2') return 2;\n    if (str == '3') return 3;\n    if (str == '4') return 4;\n    if (str == '5') return 5;\n    if (str == '6') return 6;\n    if (str == '7') return 7;\n    throw new Error(\"not a digit\");\n  };\n\n  return Chars;\n}();\n\nexports.Chars = Chars;\n/**\n * Лексема пробельного текста\n */\n\nvar WhiteSpaceLex =\n/** @class */\nfunction (_super) {\n  __extends(WhiteSpaceLex, _super);\n\n  function WhiteSpaceLex(begin, end) {\n    return _super.call(this, begin, end) || this;\n  }\n\n  WhiteSpaceLex.parse = function (str, off) {\n    if (off >= str.length) return null;\n    if (!Chars.isWS(str.substr(off, 1))) return null;\n    var from = off;\n\n    while (true) {\n      if (off >= str.length) break;\n      if (!Chars.isWS(str.substr(off, 1))) break;\n      off++;\n    }\n\n    var to = off;\n    return new WhiteSpaceLex(from, to);\n  };\n\n  return WhiteSpaceLex;\n}(AbstractLex);\n\nexports.WhiteSpaceLex = WhiteSpaceLex;\n/**\n * Лексема ключевых слов\n */\n\nvar KeyWordLex =\n/** @class */\nfunction (_super) {\n  __extends(KeyWordLex, _super);\n\n  function KeyWordLex(keyWord, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.keyWord = keyWord;\n    return _this;\n  }\n\n  KeyWordLex.parser = function (ignorecase, keyWords, keyWordBuilder) {\n    keyWords = keyWords.sort(function (a, b) {\n      return 0 - (a.length - b.length);\n    });\n    return function (str, off) {\n      if (off >= str.length) return null;\n\n      for (var _i = 0, keyWords_1 = keyWords; _i < keyWords_1.length; _i++) {\n        var kw = keyWords_1[_i];\n        var ss = str.substring(off, off + kw.length);\n\n        if (ignorecase && ss.toUpperCase() == kw.toUpperCase() || !ignorecase && ss == kw) {\n          //return new KeyWordLex(ss,off,off+ss.length)\n          if (keyWordBuilder) {\n            return keyWordBuilder(ss, off, off + ss.length);\n          } else {\n            return new KeyWordLex(ss, off, off + ss.length);\n          }\n        }\n      }\n\n      return null;\n    };\n  };\n\n  KeyWordLex.defaultKeyWordBuilder = function (kw, kwBegin, kwEnd) {\n    return new KeyWordLex(kw, kwBegin, kwEnd);\n  };\n\n  return KeyWordLex;\n}(AbstractLex);\n\nexports.KeyWordLex = KeyWordLex;\n/**\n * Лексема начала новой строки\n */\n\nvar NewLineLex =\n/** @class */\nfunction (_super) {\n  __extends(NewLineLex, _super);\n\n  function NewLineLex(keyWord, begin, end) {\n    var _this = _super.call(this, keyWord, begin, end) || this;\n\n    _this.kind = 'NewLineSeparator';\n    return _this;\n  }\n\n  NewLineLex.parse = KeyWordLex.parser(false, ['\\n\\r', '\\r\\n', '\\n', '\\r'], function (kw, begin, end) {\n    return new NewLineLex(kw, begin, end);\n  });\n  return NewLineLex;\n}(KeyWordLex);\n\nexports.NewLineLex = NewLineLex;\n/**\n * Лексема встроенного оператора\n */\n\nvar OperatorLex =\n/** @class */\nfunction (_super) {\n  __extends(OperatorLex, _super);\n\n  function OperatorLex(keyWord, begin, end) {\n    var _this = _super.call(this, keyWord, begin, end) || this;\n\n    _this.kind = 'OperatorLex';\n    return _this;\n  }\n\n  Object.defineProperty(OperatorLex.prototype, \"pow\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '^';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"mult\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '*';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"div\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '/';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"idiv\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '\\\\';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"mod\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'MOD';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"plus\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '+';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"minus\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '-';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"equals\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '=';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"notEquals\", {\n    get: function get() {\n      return this.keyWord != null && (this.keyWord == '<>' || this.keyWord == '><');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"less\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '<';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"lesOrEquals\", {\n    get: function get() {\n      return this.keyWord != null && (this.keyWord == '<=' || this.keyWord == '=<');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"more\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord == '>';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"moreOrEquals\", {\n    get: function get() {\n      return this.keyWord != null && (this.keyWord == '>=' || this.keyWord == '=>');\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"ordReleation\", {\n    get: function get() {\n      return this.more || this.moreOrEquals || this.equals || this.notEquals || this.lesOrEquals || this.less;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"not\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'NOT';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"and\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'AND';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"or\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'OR';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"xor\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'XOR';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"eqv\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'EQV';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"imp\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == 'IMP';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"arrBrOpen\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == '(';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"arrBrClose\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == ')';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(OperatorLex.prototype, \"argDelim\", {\n    get: function get() {\n      return this.keyWord != null && this.keyWord.toUpperCase() == ',';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  OperatorLex.parse = KeyWordLex.parser(true, ['(', ')', // математические операции в порядке уменьшения приоритета\n  '^', '*', '/', '\\\\', 'MOD', '+', '-', '=', '<>', '><', '<', '>', '<=', '>=', '=>', 'NOT', 'AND', 'OR', 'XOR', // 1 XOR 1 = 0\n  // 1 XOR 0 = 1\n  // 0 XOR 1 = 1\n  // 0 XOR 0 = 0\n  'EQV', // 1 EQV 1 = 1\n  // 1 EQV 0 = 0\n  // 0 EQV 1 = 0\n  // 0 EQV 0 = 1\n  'IMP', // 0 IMP 0 = 1\n  // 0 IMP 1 = 1\n  // 1 IMP 0 = 0\n  // 1 IMP 1 = 1\n  ','], function (kw, begin, end) {\n    return new OperatorLex(kw, begin, end);\n  });\n  return OperatorLex;\n}(KeyWordLex);\n\nexports.OperatorLex = OperatorLex;\n\nvar StatementLex =\n/** @class */\nfunction (_super) {\n  __extends(StatementLex, _super);\n\n  function StatementLex(keyWord, begin, end) {\n    var _this = _super.call(this, keyWord, begin, end) || this;\n\n    _this.kind = 'StatementLex';\n    return _this;\n  }\n\n  Object.defineProperty(StatementLex.prototype, \"LET\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'LET';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"RUN\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'RUN';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"GOTO\", {\n    get: function get() {\n      if (this.keyWord.toUpperCase() == 'GOTO') return true;\n      if (this.keyWord.toUpperCase() == 'GO TO') return true;\n      return false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"IF\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'IF';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"THEN\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'THEN';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"ELSE\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'ELSE';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"GOSUB\", {\n    get: function get() {\n      if (this.keyWord.toUpperCase() == 'GO SUB') return true;\n      if (this.keyWord.toUpperCase() == 'GOSUB') return true;\n      return false;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"RETURN\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'RETURN';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(StatementLex.prototype, \"PRINT\", {\n    get: function get() {\n      return this.keyWord.toUpperCase() == 'PRINT';\n    },\n    enumerable: true,\n    configurable: true\n  }); //get LIST() { return this.keyWord.toUpperCase()=='LIST' }\n\n  StatementLex.parse = KeyWordLex.parser(true, ['LET', 'RUN', 'GOTO', 'GO TO', 'IF', 'THEN', 'ELSE', 'GO SUB', 'GOSUB', 'RETURN', 'PRINT'], function (kw, begin, end) {\n    return new StatementLex(kw, begin, end);\n  });\n  return StatementLex;\n}(KeyWordLex);\n\nexports.StatementLex = StatementLex;\n/**\n * Пустая лексема\n */\n\nvar DummyLex =\n/** @class */\nfunction (_super) {\n  __extends(DummyLex, _super);\n\n  function DummyLex() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  return DummyLex;\n}(AbstractLex);\n\nexports.DummyLex = DummyLex;\n/**\n * Лексема коментарий\n */\n\nvar RemLex =\n/** @class */\nfunction (_super) {\n  __extends(RemLex, _super);\n\n  function RemLex(cmnt, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.comment = cmnt;\n    _this.kind = 'RemLex';\n    return _this;\n  }\n\n  RemLex.parse = function (str, off) {\n    if (off >= str.length) return null;\n    var rm1 = str.substring(off, off + 4);\n\n    if (rm1.toUpperCase() == 'REM') {\n      return new RemLex('', off, off + rm1.length);\n    }\n\n    if (!(rm1.toUpperCase() == 'REM ')) return null;\n    var begin = off;\n    off += 4;\n\n    while (true) {\n      if (off >= str.length) break;\n\n      if (Chars.isNewline(str.substring(off, off + 1))) {\n        break;\n      }\n\n      off++;\n    }\n\n    var end = off;\n    var cmntBegin = begin + 4;\n    return new RemLex(str.substring(cmntBegin, end), begin, end);\n  };\n\n  return RemLex;\n}(AbstractLex);\n\nexports.RemLex = RemLex;\n/**\n * См https://robhagemans.github.io/pcbasic/doc/1.2/#literals\n */\n\nvar NumberLex =\n/** @class */\nfunction (_super) {\n  __extends(NumberLex, _super);\n\n  function NumberLex(val, integer, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.value = val;\n    _this.integer = integer;\n    _this.kind = 'NumberLiteral';\n    return _this;\n  }\n\n  NumberLex.parseOct = function (str, off) {\n    //console.log(\"parseOct\")\n    if (off >= str.length) return null;\n    var head = str.substring(off, off + 2);\n    if (!(head == '&o' || head == '&O')) return null;\n    var num = 0;\n    var kSys = 8;\n    var begin = off;\n    off += 2;\n\n    while (true) {\n      if (off >= str.length) break;\n      var chDgt = str.substring(off, off + 1);\n\n      if (!Chars.isOctDigit(chDgt)) {\n        break;\n      }\n\n      num = num * kSys + Chars.octDigit(chDgt);\n      off++;\n    }\n\n    var end = off;\n    return new NumberLex(num, true, begin, end);\n  };\n\n  NumberLex.parseHex = function (str, off) {\n    //console.log(\"parseHex\")\n    if (off >= str.length) return null;\n    var head = str.substring(off, off + 2);\n    if (!(head == '&h' || head == '&H')) return null;\n    var num = 0;\n    var kSys = 16;\n    var begin = off;\n    off += 2;\n\n    while (true) {\n      if (off >= str.length) break;\n      var chDgt = str.substring(off, off + 1);\n\n      if (!Chars.isHexDigit(chDgt)) {\n        break;\n      }\n\n      num = num * kSys + Chars.hexDigit(chDgt);\n      off++;\n    }\n\n    var end = off;\n    return new NumberLex(num, true, begin, end);\n  };\n\n  NumberLex.parseDec = function (str, off) {\n    //console.log(\"parseDec\")\n    if (off >= str.length) return null;\n    var head = str.substring(off);\n    /*\n    > \"+1234.22e+6%\".match( /^([+\\-]\\d+)((\\.\\d+)(([eEdD])([+\\-]?\\d+))?)?([%\\#!])?/ )\n    [ '+1234.22e+6%',\n    '+1234',\n    '.22e+6',\n    '.22',\n    'e+6',\n    'e',\n    '+6',\n    '%',\n    index: 0,\n    input: '+1234.22e+6%',\n    groups: undefined ]\n    */\n\n    var m1 = head.match(/^([+\\-]?\\d+)((\\.\\d+)(([eEdD])([+\\-]?\\d+))?)?([%\\#!])?/);\n\n    if (m1) {\n      var integer = true;\n      var p1 = m1[1];\n      if (m1[3]) p1 = p1 + m1[3]; //float part\n\n      if (m1[5] && (m1[5] == 'e' || m1[5] == 'E')) {\n        p1 = p1 + m1[4]; // expo\n\n        integer = false;\n      }\n\n      if (m1[5] && (m1[5] == 'd' || m1[5] == 'D')) {\n        integer = false;\n      }\n\n      if (m1[3] && m1[3].length > 0) {\n        integer = false;\n      }\n\n      var num = parseFloat(p1);\n      var begin = off;\n      var end = off + m1[0].length;\n      return new NumberLex(num, integer, begin, end);\n    }\n\n    return null;\n  };\n\n  NumberLex.parse = function (str, off) {\n    var octn = NumberLex.parseOct(str, off);\n    if (octn) return octn;\n    var hexn = NumberLex.parseHex(str, off);\n    if (hexn) return hexn;\n    var decn = NumberLex.parseDec(str, off);\n    return decn;\n  };\n\n  Object.defineProperty(NumberLex.prototype, \"asSourceLine\", {\n    /**\n     * Конвертирует в номер исходной строки\n     */\n    get: function get() {\n      return new SourceLineBeginLex(this.value, this.begin, this.end);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return NumberLex;\n}(AbstractLex);\n\nexports.NumberLex = NumberLex;\n/**\n * Строковая лексема\n */\n\nvar StringLex =\n/** @class */\nfunction (_super) {\n  __extends(StringLex, _super);\n\n  function StringLex(val, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.value = val;\n    _this.kind = 'StringLiteral';\n    return _this;\n  }\n\n  StringLex.parse = function (str, off) {\n    if (off >= str.length) return null;\n    if (!(str.substring(off, off + 1) == '\"')) return null;\n    var begin = off;\n    off++;\n    var sBegin = off;\n    var sEnd = -1;\n\n    while (true) {\n      if (off >= str.length) break;\n      var ch = str.substring(off, off + 1);\n\n      if (ch == '\"') {\n        sEnd = off;\n        off++;\n        break;\n      }\n\n      if (Chars.isNewline(ch)) {\n        sEnd = off;\n        break;\n      }\n\n      off++;\n    }\n\n    var end = off;\n    var sVal = str.substring(sBegin, off);\n\n    if (sEnd > sBegin) {\n      sVal = str.substring(sBegin, sEnd);\n    }\n\n    return new StringLex(sVal, begin, end);\n  };\n\n  return StringLex;\n}(AbstractLex);\n\nexports.StringLex = StringLex;\n/**\n * Идентификатор\n */\n\nvar IDLex =\n/** @class */\nfunction (_super) {\n  __extends(IDLex, _super);\n\n  function IDLex(id, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.id = id;\n    _this.kind = 'ID';\n    return _this;\n  }\n\n  IDLex.parse = function (str, off) {\n    if (off >= str.length) return null;\n    var head = str.substring(off);\n    var m1 = head.match(/^[a-zA-Z][a-zA-Z0-9\\.]*[\\#\\!\\%\\$]?/);\n\n    if (m1) {\n      var s = m1[0];\n      return new IDLex(s, off, off + s.length);\n    }\n\n    return null;\n  };\n\n  return IDLex;\n}(AbstractLex);\n\nexports.IDLex = IDLex;\n/**\n * Лексемы языка BASIC\n */\n\nexports.basicLexems = [NewLineLex.parse, WhiteSpaceLex.parse, RemLex.parse, StatementLex.parse, OperatorLex.parse, IDLex.parse, NumberLex.parse, StringLex.parse];\n/**\n * Маркер начала строки\n */\n\nvar SourceLineBeginLex =\n/** @class */\nfunction (_super) {\n  __extends(SourceLineBeginLex, _super);\n\n  function SourceLineBeginLex(line, begin, end) {\n    var _this = _super.call(this, begin, end) || this;\n\n    _this.line = line;\n    _this.kind = 'SourceLine';\n    return _this;\n  }\n\n  return SourceLineBeginLex;\n}(AbstractLex);\n\nexports.SourceLineBeginLex = SourceLineBeginLex;\n/**\n * Фильтр лексем\n */\n\nvar LexIterate =\n/** @class */\nfunction () {\n  function LexIterate(lexs) {\n    this.lexs = lexs;\n  }\n\n  LexIterate.prototype.get = function () {\n    return this.lexs;\n  };\n\n  Object.defineProperty(LexIterate.prototype, \"dropWhitespace\", {\n    /**\n     * Удаляет лексемы пробельных символов\n     */\n    get: function get() {\n      var lexs = [];\n\n      for (var _i = 0, _a = this.lexs; _i < _a.length; _i++) {\n        var lx = _a[_i];\n\n        if (!(lx instanceof WhiteSpaceLex)) {\n          lexs.push(lx);\n        }\n      }\n\n      return new LexIterate(lexs);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LexIterate.prototype, \"dropNewLines\", {\n    /**\n     * Удаляет лексемы перевода строк\n     */\n    get: function get() {\n      var lexs = [];\n\n      for (var _i = 0, _a = this.lexs; _i < _a.length; _i++) {\n        var lx = _a[_i];\n\n        if (!(lx instanceof NewLineLex)) {\n          lexs.push(lx);\n        }\n      }\n\n      return new LexIterate(lexs);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LexIterate.prototype, \"lines\", {\n    /**\n     * Разбивает лексемы на набор строк\n     */\n    get: function get() {\n      var lines = [];\n      var line = [];\n\n      for (var _i = 0, _a = this.lexs; _i < _a.length; _i++) {\n        var lx = _a[_i];\n\n        if (lx instanceof SourceLineBeginLex) {\n          if (line.length > 0) {\n            lines.push(line);\n          }\n\n          line = [lx];\n        } else {\n          line.push(lx);\n        }\n      }\n\n      if (line.length > 0) {\n        lines.push(line);\n      }\n\n      return lines;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LexIterate;\n}();\n\nexports.LexIterate = LexIterate;\n/**\n * Фильтр лексем\n * @param lexs лексемы\n */\n\nfunction filter(lexs) {\n  return new LexIterate(lexs);\n}\n\nexports.filter = filter;\n\nvar isStatement = function isStatement(lx) {\n  if (lx == undefined) return false;\n  if (lx == null) return false;\n  if (lx instanceof RemLex) return true;\n  if (lx instanceof StatementLex) return true;\n  return false;\n};\n/**\n * Лексический анализ\n * @param source исходный текст\n */\n\n\nfunction parseBasicLexs(source) {\n  var lexs = lexems(source, exports.basicLexems);\n  lexs = filter(lexs).dropWhitespace.lexs;\n  var res = [];\n\n  for (var i = 0; i < lexs.length; i++) {\n    if (i == 0) {\n      if (lexs[i] instanceof NumberLex && i + 1 < lexs.length && isStatement(lexs[i + 1])) {\n        res.push(new SourceLineBeginLex(lexs[i].value, lexs[i].begin, lexs[i].end));\n      } else {\n        res.push(lexs[i]);\n      }\n    } else {\n      if (lexs[i - 1] instanceof NewLineLex && lexs[i] instanceof NumberLex) {\n        res.push(new SourceLineBeginLex(lexs[i].value, lexs[i].begin, lexs[i].end));\n      } else {\n        res.push(lexs[i]);\n      }\n    }\n  } //return res\n\n\n  return filter(res).dropNewLines.lexs;\n}\n\nexports.parseBasicLexs = parseBasicLexs;\n\n//# sourceURL=webpack:///./out/ts/ast/Lexer.js?");

/***/ }),

/***/ "./out/ts/ast/OperatorExp.js":
/*!***********************************!*\
  !*** ./out/ts/ast/OperatorExp.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar TreeIt_1 = __webpack_require__(/*! ../TreeIt */ \"./out/ts/TreeIt.js\");\n\nvar AExpression =\n/** @class */\nfunction () {\n  function AExpression() {}\n\n  Object.defineProperty(AExpression.prototype, \"treeSize\", {\n    get: function get() {\n      if (this.treeSizeValue !== undefined) return this.treeSizeValue;\n      this.treeSizeValue = this.treeList.length;\n      return this.treeSizeValue;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AExpression.prototype, \"treeList\", {\n    get: function get() {\n      return TreeIt_1.TreeIt.list(this, function (n) {\n        return n.children;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AExpression.prototype, \"treeLexList\", {\n    get: function get() {\n      var arr = [];\n      this.treeList.forEach(function (exp) {\n        exp.value.lexems.forEach(function (lx) {\n          return arr.push(lx);\n        });\n      });\n      return arr;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AExpression.prototype, \"leftTreeLex\", {\n    get: function get() {\n      var lxs = this.treeLexList;\n      if (lxs.length < 1) return undefined;\n      if (lxs.length == 1) return lxs[0];\n      return lxs.reduce(function (a, b) {\n        return a.begin > b.begin ? b : a;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AExpression.prototype, \"rightTreeLex\", {\n    get: function get() {\n      var lxs = this.treeLexList;\n      if (lxs.length < 1) return undefined;\n      if (lxs.length == 1) return lxs[0];\n      return lxs.reduce(function (a, b) {\n        return a.begin > b.begin ? a : b;\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return AExpression;\n}();\n\nexports.AExpression = AExpression;\n/**\n * Константное значение (Литерал - строка/число/и т.д...)\n */\n\nvar LiteralExpression =\n/** @class */\nfunction (_super) {\n  __extends(LiteralExpression, _super);\n\n  function LiteralExpression(lex, value) {\n    var _this = _super.call(this) || this;\n\n    _this.lex = lex;\n    _this.value = value;\n    _this.lexems = [lex];\n    _this.children = [];\n    _this.kind = 'Literal';\n    return _this;\n  }\n\n  return LiteralExpression;\n}(AExpression);\n\nexports.LiteralExpression = LiteralExpression;\n/**\n * Ссылка на переменную\n */\n\nvar VarRefExpression =\n/** @class */\nfunction (_super) {\n  __extends(VarRefExpression, _super);\n\n  function VarRefExpression(lex) {\n    var _this = _super.call(this) || this;\n\n    _this.id = lex;\n    _this.lexems = [lex];\n    _this.children = [];\n    _this.kind = 'VarRef';\n    return _this;\n  }\n\n  Object.defineProperty(VarRefExpression.prototype, \"varname\", {\n    get: function get() {\n      return this.id.id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return VarRefExpression;\n}(AExpression);\n\nexports.VarRefExpression = VarRefExpression;\n/**\n * Ссылка на значение массива\n */\n\nvar VarArrIndexRef =\n/** @class */\nfunction (_super) {\n  __extends(VarArrIndexRef, _super);\n\n  function VarArrIndexRef(lex, indexes) {\n    var _this = _super.call(this, lex) || this;\n\n    _this.indexes = indexes;\n    return _this;\n  }\n\n  return VarArrIndexRef;\n}(VarRefExpression);\n\nexports.VarArrIndexRef = VarArrIndexRef;\n/**\n * Бинарная операция\n */\n\nvar BinaryOpExpression =\n/** @class */\nfunction (_super) {\n  __extends(BinaryOpExpression, _super);\n\n  function BinaryOpExpression(op, left, right) {\n    var _this = _super.call(this) || this;\n\n    _this.operator = op;\n    _this.left = left;\n    _this.right = right;\n    _this.lexems = [op];\n    _this.children = [left, right];\n    _this.kind = 'BinaryOperator';\n    return _this;\n  }\n\n  return BinaryOpExpression;\n}(AExpression);\n\nexports.BinaryOpExpression = BinaryOpExpression;\n/**\n * Унраная операция\n */\n\nvar UnaryOpExpression =\n/** @class */\nfunction (_super) {\n  __extends(UnaryOpExpression, _super);\n\n  function UnaryOpExpression(op, base) {\n    var _this = _super.call(this) || this;\n\n    _this.operator = op;\n    _this.base = base;\n    _this.lexems = [op];\n    _this.children = [base];\n    _this.kind = 'UnaryOperator';\n    return _this;\n  }\n\n  return UnaryOpExpression;\n}(AExpression);\n\nexports.UnaryOpExpression = UnaryOpExpression;\n\n//# sourceURL=webpack:///./out/ts/ast/OperatorExp.js?");

/***/ }),

/***/ "./out/ts/ast/Parser.js":
/*!******************************!*\
  !*** ./out/ts/ast/Parser.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Pointer_1 = __webpack_require__(/*! ./Pointer */ \"./out/ts/ast/Pointer.js\");\n\nvar Lexer_1 = __webpack_require__(/*! ./Lexer */ \"./out/ts/ast/Lexer.js\");\n\nvar RemStatement_1 = __webpack_require__(/*! ./RemStatement */ \"./out/ts/ast/RemStatement.js\");\n\nvar Statements_1 = __webpack_require__(/*! ./Statements */ \"./out/ts/ast/Statements.js\");\n\nvar OperatorExp_1 = __webpack_require__(/*! ./OperatorExp */ \"./out/ts/ast/OperatorExp.js\");\n\nvar LetStatement_1 = __webpack_require__(/*! ./LetStatement */ \"./out/ts/ast/LetStatement.js\");\n\nvar RunStatement_1 = __webpack_require__(/*! ./RunStatement */ \"./out/ts/ast/RunStatement.js\");\n\nvar GotoStatement_1 = __webpack_require__(/*! ./GotoStatement */ \"./out/ts/ast/GotoStatement.js\");\n\nvar IfStatement_1 = __webpack_require__(/*! ./IfStatement */ \"./out/ts/ast/IfStatement.js\");\n\nvar GoSubStatement_1 = __webpack_require__(/*! ./GoSubStatement */ \"./out/ts/ast/GoSubStatement.js\");\n\nvar ReturnStatement_1 = __webpack_require__(/*! ./ReturnStatement */ \"./out/ts/ast/ReturnStatement.js\");\n\nvar PrintStatement_1 = __webpack_require__(/*! ./PrintStatement */ \"./out/ts/ast/PrintStatement.js\");\n/**\n * Опции парсера\n */\n\n\nvar Options =\n/** @class */\nfunction () {\n  function Options() {\n    /**\n     * парсинг statement с учетом номера строки\n     */\n    this.tryLineNum = true;\n  }\n  /**\n   * Клонирование\n   */\n\n\n  Options.prototype.clone = function (conf) {\n    var c = new Options();\n    c.tryLineNum = this.tryLineNum;\n\n    if (conf) {\n      conf(c);\n    }\n\n    return c;\n  };\n\n  return Options;\n}();\n\nexports.Options = Options;\n/**\n * Парсинг BASIC\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  /**\n   * Конструктор\n   * @param lexs лексемы\n   */\n  function Parser(lexs) {\n    this.debug = false;\n    /**\n     * Опции\n     */\n\n    this.options = new Options();\n    this.ptr = new Pointer_1.Pointer(lexs);\n  }\n  /**\n   * Конструктор\n   * @param source исходный текст\n   */\n\n\n  Parser.create = function (source) {\n    return new Parser(Lexer_1.parseBasicLexs(source));\n  };\n\n  Parser.prototype.log = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (this.debug) {\n      console.log.apply(console, args);\n    }\n  };\n  /**\n   * statements ::= { statement }\n   */\n\n\n  Parser.prototype.statements = function () {\n    var res = [];\n    if (this.ptr.eof) return null;\n    var total = this.ptr.entries.length;\n    var tailEntries = this.ptr.gets(total - this.ptr.ptr);\n    var lines = Lexer_1.filter(tailEntries).lines;\n    var firstLex = null;\n    var lastLex = null;\n    this.log(\"statements() lines:\", lines);\n\n    for (var li = 0; li < lines.length; li++) {\n      var lineLex = lines[li];\n\n      if (firstLex == null && lineLex.length > 0) {\n        firstLex = lineLex[0];\n      }\n\n      if (lineLex.length > 0) {\n        lastLex = lineLex[lineLex.length - 1];\n      }\n\n      this.log(\"statements() line:\", lineLex);\n      var lineParser = new Parser(lineLex);\n      lineParser.debug = this.debug;\n\n      while (!lineParser.ptr.eof) {\n        var lineStatement = lineParser.statement();\n\n        if (lineStatement) {\n          res.push(lineStatement);\n        } else {\n          throw new Error(\"can't parse line: \" + JSON.stringify(lineParser.ptr.gets(5)));\n        }\n      }\n    }\n\n    if (firstLex != null && lastLex != null) {\n      return new Statements_1.Statements(firstLex, lastLex, res);\n    }\n\n    return new Statements_1.Statements(new Lexer_1.DummyLex(-1, -1), new Lexer_1.DummyLex(-1, -1), res);\n  };\n  /**\n   * statement ::= remStatement\n   *             | letStatement\n   *             | runStatement\n   *             | gotoStatement\n   *             | ifStatement\n   *             | gosubStatement\n   *             | returnStatement\n   */\n\n\n  Parser.prototype.statement = function (opts) {\n    if (!opts) {\n      opts = this.options;\n    }\n\n    this.log('statement() ptr=', this.ptr.gets(3));\n    var remStmt = this.remStatement(opts);\n    if (remStmt) return remStmt;\n    var letStmt = this.letStatement(opts);\n    if (letStmt) return letStmt;\n    var runStmt = this.runStatement(opts);\n    if (runStmt) return runStmt;\n    var gotoStmt = this.gotoStatement(opts);\n    if (gotoStmt) return gotoStmt;\n    var ifStmt = this.ifStatement(opts);\n    if (ifStmt) return ifStmt;\n    var gosubStmt = this.gosubStatement(opts);\n    if (gosubStmt) return gosubStmt;\n    var returnStmt = this.returnStatement(opts);\n    if (returnStmt) return returnStmt;\n    var printStmt = this.printStatement(opts);\n    if (printStmt) return printStmt;\n    return null;\n  };\n  /**\n   * Проверка если текущая лексема обозначает начало нумерованной строки,\n   * то лексема и номер строки передается в функцию,\n   * а указатель смещается к след лексеме.\n   *\n   * Функция модет вернуть null, тогда будет восстановлена позиция\n   * @param proc функция принимающая номер строки\n   */\n\n\n  Parser.prototype.matchLine = function (proc) {\n    var lineNum = undefined;\n    var lineNumLex = this.ptr.get(0);\n\n    if (lineNumLex instanceof Lexer_1.SourceLineBeginLex || lineNumLex instanceof Lexer_1.NumberLex) {\n      if (lineNumLex instanceof Lexer_1.SourceLineBeginLex) {\n        lineNum = lineNumLex.line;\n      }\n\n      if (lineNumLex instanceof Lexer_1.NumberLex) {\n        lineNum = lineNumLex.value;\n      }\n\n      if (lineNum) {\n        this.ptr.push();\n        this.ptr.move(1);\n        var res = proc({\n          line: lineNum,\n          lex: lineNumLex\n        });\n\n        if (res) {\n          this.ptr.drop();\n          return res;\n        }\n\n        this.ptr.pop();\n      }\n    }\n\n    return null;\n  };\n  /**\n   * remStatement ::= SourceLineBeginLex RemLex\n   *                | NumberLex RemLex\n   *                | RemLex\n   */\n\n\n  Parser.prototype.remStatement = function (opts) {\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n\n    var _a = this.ptr.gets(2),\n        lex1 = _a[0],\n        lex2 = _a[1];\n\n    if (lex1 instanceof Lexer_1.SourceLineBeginLex && lex2 instanceof Lexer_1.RemLex && opts.tryLineNum) {\n      this.ptr.move(2);\n      return new RemStatement_1.RemStatement(lex1, lex2, lex2);\n    }\n\n    if (lex1 instanceof Lexer_1.NumberLex && lex2 instanceof Lexer_1.RemLex && opts.tryLineNum) {\n      this.ptr.move(2);\n      return new RemStatement_1.RemStatement(lex1.asSourceLine, lex2, lex2);\n    }\n\n    if (lex1 instanceof Lexer_1.RemLex) {\n      this.ptr.move(1);\n      return new RemStatement_1.RemStatement(lex1, lex1, lex1);\n    }\n\n    return null;\n  };\n  /**\n   * letStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                  StatementLex(LET) IDLex OperatorLex(=) expression\n   */\n\n\n  Parser.prototype.letStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null; // let lineNum : number | undefined = undefined\n    // let lineNumLex = this.ptr.get(0)\n    // let off = 0\n    // if( opts.tryLineNum && \n    //     (  lineNumLex instanceof SourceLineBeginLex \n    //     || lineNumLex instanceof NumberLex \n    //     )\n    // ){\n    //     if( lineNumLex instanceof SourceLineBeginLex ){\n    //         lineNum = lineNumLex.line\n    //     }\n    //     if( lineNumLex instanceof NumberLex ){\n    //         lineNum = lineNumLex.value\n    //     }\n    //     off = 1\n    // }\n\n    var prod = function prod(arg) {\n      _this.ptr.push();\n\n      var lexLet = _this.ptr.get();\n\n      if (lexLet instanceof Lexer_1.StatementLex && lexLet.LET) {\n        _this.ptr.move(1);\n      } else {\n        _this.ptr.pop();\n\n        return null;\n      }\n\n      var lexId = _this.ptr.get();\n\n      if (lexId instanceof Lexer_1.IDLex) {\n        var lxNext = _this.ptr.get(1);\n\n        if (lxNext instanceof Lexer_1.OperatorLex && lxNext.keyWord == '=') {\n          _this.ptr.move(2);\n\n          var exp = _this.expression();\n\n          if (exp) {\n            var begin = arg ? arg.lex : lexLet;\n            var end = exp.rightTreeLex || begin;\n\n            _this.ptr.drop();\n\n            return new LetStatement_1.LetStatement(begin, end, lexId, exp);\n          }\n        } // if( lxNext instanceof OperatorLex && lxNext.arrBrOpen ){\n        //     this.ptr.move(2)\n        //     //let exp\n        // }\n\n      }\n\n      _this.ptr.pop();\n\n      return null;\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    } // let lexLet = this.ptr.get(off)\n    // if( lexLet instanceof StatementLex && \n    //     lexLet.LET\n    // ){\n    //     let [ lexId, lxNext ] = this.ptr.fetch(off+1,2)\n    //     if( lxNext instanceof OperatorLex && lxNext.keyWord == '=' \n    //     &&  lexId instanceof IDLex\n    //     ){\n    //         // parsing...\n    //         this.ptr.push()\n    //         let begin = this.ptr.get() || lexLet\n    //         this.ptr.move(off+3)\n    //         let exp = this.expression()\n    //         if( exp ){\n    //             this.ptr.drop()\n    //             let end = exp.rightTreeLex || begin\n    //             return new LetStatement(begin,end,lexId,exp)\n    //         }else{\n    //             // syntax error\n    //             this.ptr.pop()\n    //             return null\n    //         }\n    //     }else{\n    //         // syntax error\n    //         return null\n    //     }\n    // }\n    // return null\n\n  };\n  /**\n   * runStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                  StatementLex(RUN) [lineNumber : NumberLex]\n   */\n\n\n  Parser.prototype.runStatement = function (opts) {\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('runStatement() ptr=', this.ptr.gets(3));\n    var lineNum = undefined;\n    var lineNumLex = this.ptr.get(0);\n    var off = 0;\n\n    if (opts.tryLineNum && (lineNumLex instanceof Lexer_1.SourceLineBeginLex || lineNumLex instanceof Lexer_1.NumberLex)) {\n      if (lineNumLex instanceof Lexer_1.SourceLineBeginLex) {\n        lineNum = lineNumLex.line;\n      }\n\n      if (lineNumLex instanceof Lexer_1.NumberLex) {\n        lineNum = lineNumLex.value;\n      }\n\n      off = 1;\n    }\n\n    var runLex = this.ptr.get(off);\n\n    if (runLex instanceof Lexer_1.StatementLex && runLex.RUN) {\n      this.log('runStatement() RUN');\n      var runLineLex = this.ptr.get(off + 1);\n\n      if (runLineLex instanceof Lexer_1.NumberLex) {\n        off += 2;\n        this.ptr.move(off);\n        this.log('runStatement() move ', off, {\n          eof: this.ptr.eof,\n          gets3: this.ptr.gets(3)\n        });\n        return new RunStatement_1.RunStatement(lineNumLex || runLex, runLineLex, runLineLex);\n      }\n\n      off += 1;\n      this.ptr.move(off);\n      return new RunStatement_1.RunStatement(lineNumLex || runLex, runLex);\n    }\n\n    return null;\n  };\n  /**\n   * gotoStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                   StatementLex(GOTO) lineNumber:NumberLex\n   * @param opts опции компилятора\n   */\n\n\n  Parser.prototype.gotoStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('gotoStatement() ptr=', this.ptr.gets(3));\n\n    var prod = function prod(linf) {\n      var _a = _this.ptr.gets(2),\n          gtLex = _a[0],\n          gtLine = _a[1];\n\n      if (gtLex instanceof Lexer_1.StatementLex && gtLex.GOTO && gtLine instanceof Lexer_1.NumberLex) {\n        _this.ptr.move(2);\n\n        return new GotoStatement_1.GotoStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n      }\n\n      return null;\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    }\n  };\n  /**\n   * gotoStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                   StatementLex(GOSUB) lineNumber:NumberLex\n   * @param opts опции компилятора\n   */\n\n\n  Parser.prototype.gosubStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('gosubStatement() ptr=', this.ptr.gets(3));\n\n    var prod = function prod(linf) {\n      var _a = _this.ptr.gets(2),\n          gtLex = _a[0],\n          gtLine = _a[1];\n\n      if (gtLex instanceof Lexer_1.StatementLex && gtLex.GOSUB && gtLine instanceof Lexer_1.NumberLex) {\n        _this.ptr.move(2);\n\n        return new GoSubStatement_1.GoSubStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n      }\n\n      return null;\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    }\n  };\n  /**\n   * returnStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                   StatementLex(RETURN) [lineNumber:NumberLex]\n   * @param opts опции компилятора\n   */\n\n\n  Parser.prototype.returnStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('returnStatement() ptr=', this.ptr.gets(3));\n\n    var prod = function prod(linf) {\n      var gtLex = _this.ptr.gets(1)[0];\n\n      if (gtLex instanceof Lexer_1.StatementLex && gtLex.RETURN) {\n        _this.ptr.move(1);\n\n        var gtLine = _this.ptr.fetch(0, 1)[0];\n\n        if (gtLine instanceof Lexer_1.NumberLex) {\n          _this.ptr.move(1);\n\n          return new ReturnStatement_1.ReturnStatement(linf ? linf.lex : gtLex, gtLine, gtLine);\n        } else {\n          return new ReturnStatement_1.ReturnStatement(linf ? linf.lex : gtLex, gtLine);\n        }\n      }\n\n      return null;\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    }\n  };\n  /**\n   * ifStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                 StatementLex(IF) expression\n   *                 StatementLex(THEN) statement\n   *                 [StatementLex(ELSE) statement]\n   * @param opts опции компилятора\n   */\n\n\n  Parser.prototype.ifStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('ifStatement() ptr=', this.ptr.gets(3));\n\n    var prod = function prod(linf) {\n      var ifLx = _this.ptr.get();\n\n      console.log(\"ifLx \", ifLx);\n      if (!ifLx) return null;\n      if (!(ifLx instanceof Lexer_1.StatementLex)) return null;\n      if (!ifLx.IF) return null;\n\n      _this.ptr.push();\n\n      _this.ptr.move(1);\n\n      var exp = _this.expression();\n\n      if (!exp) {\n        _this.ptr.pop();\n\n        return null;\n      }\n\n      var thenLx = _this.ptr.get();\n\n      if (thenLx instanceof Lexer_1.StatementLex && !thenLx.THEN) {\n        _this.ptr.pop();\n\n        return null;\n      }\n\n      _this.ptr.move(1);\n\n      var conf = function conf(op) {\n        op.tryLineNum = false;\n      };\n\n      var trueSt = _this.statement(opts ? opts.clone(conf) : _this.options.clone(conf));\n\n      if (trueSt == null) {\n        _this.ptr.pop();\n\n        return null;\n      }\n\n      var elseLx = _this.ptr.get();\n\n      var falseSt = null;\n\n      if (elseLx instanceof Lexer_1.StatementLex && elseLx.ELSE) {\n        _this.ptr.push();\n\n        _this.ptr.move(1);\n\n        falseSt = _this.statement(opts ? opts.clone(conf) : _this.options.clone(conf));\n\n        if (falseSt) {\n          _this.ptr.drop();\n        } else {\n          _this.ptr.pop();\n        }\n      }\n\n      _this.ptr.drop();\n\n      if (falseSt) {\n        return new IfStatement_1.IfStatement(linf ? linf.lex : ifLx, falseSt ? falseSt.end : trueSt.end, exp, trueSt, falseSt);\n      }\n\n      return new IfStatement_1.IfStatement(linf ? linf.lex : ifLx, trueSt.end, exp, trueSt);\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    }\n  };\n  /**\n   * printStatement ::= [ SourceLineBeginLex | NumberLex ]\n   *                    StatementLex(PRINT) [expression {',' expression}]\n   * @param opts опции компилятора\n   */\n\n\n  Parser.prototype.printStatement = function (opts) {\n    var _this = this;\n\n    if (!opts) {\n      opts = this.options;\n    }\n\n    if (this.ptr.eof) return null;\n    this.log('printStatement() ptr=', this.ptr.gets(3));\n\n    var prod = function prod(linf) {\n      var gtLex = _this.ptr.gets(1)[0];\n\n      if (gtLex instanceof Lexer_1.StatementLex && gtLex.PRINT) {\n        _this.ptr.move(1);\n\n        var exps = [];\n        var lastLex = gtLex;\n\n        while (true) {\n          if (exps.length > 0) {\n            var lNext = _this.ptr.get();\n\n            if (!(lNext && lNext instanceof Lexer_1.OperatorLex && lNext.argDelim)) {\n              break;\n            } else {\n              _this.ptr.move(1);\n            }\n          }\n\n          _this.ptr.push();\n\n          var exp = _this.expression();\n\n          if (exp) {\n            exps.push(exp);\n\n            if (exp.rightTreeLex) {\n              lastLex = exp.rightTreeLex;\n            }\n          } else {\n            _this.ptr.pop();\n\n            if (exps.length > 0) {//TODO here error report\n            }\n\n            break;\n          }\n        }\n\n        return new PrintStatement_1.PrintStatement(linf ? linf.lex : gtLex, lastLex, gtLex, exps);\n      }\n\n      return null;\n    };\n\n    if (opts.tryLineNum) {\n      return this.matchLine(prod) || prod();\n    } else {\n      return prod();\n    }\n  };\n  /**\n   * expression ::= impExpression | bracketExpression\n   */\n\n\n  Parser.prototype.expression = function () {\n    this.log('expression() ptr=', this.ptr.gets(3));\n    var powExp = this.impExpression();\n    if (powExp) return powExp;\n    var brExp = this.bracketExpression();\n    if (brExp) return brExp;\n    return null;\n  };\n  /**\n   * bracketExpression ::= '(' expression ')'\n   */\n\n\n  Parser.prototype.bracketExpression = function () {\n    if (this.ptr.eof) return null;\n    var leftBr = this.ptr.get(0);\n\n    if (leftBr instanceof Lexer_1.KeyWordLex && leftBr.keyWord == '(') {\n      this.ptr.push();\n      this.ptr.move(1);\n      var exp = this.expression();\n\n      if (exp) {\n        var rightBr = this.ptr.get(0);\n\n        if (rightBr instanceof Lexer_1.KeyWordLex && rightBr.keyWord == ')') {\n          this.ptr.move(1);\n          this.ptr.drop();\n          return exp;\n        }\n      }\n\n      this.ptr.pop();\n    }\n\n    return null;\n  };\n  /**\n   * Парсинг циклической конструкции:\n   * leftOp { operator rightExp }\n   *\n   * Проверяет что текущая лексема (operator) соответ указанной (accpetOperator),\n   * и если это так, то производит анализ правого операнда (rightExp)\n   * В результате создает последовательность (дерево растет в лево)\n   * бинарных операторов\n   * @param ruleName имя правила\n   * @param leftOp левый уже вычесленный операнд\n   * @param rightExp вычисление правого операнда\n   * @param accpetOperator проверка оператора\n   */\n\n\n  Parser.prototype.binaryRepeatExpression = function (ruleName, leftOp, rightExp, accpetOperator) {\n    var res = leftOp;\n\n    while (true) {\n      var lx = this.ptr.get();\n\n      if (lx instanceof Lexer_1.OperatorLex && accpetOperator(lx)) {\n        this.ptr.move(1);\n        var rightOp = rightExp();\n        this.log(ruleName + \" right=\", rightOp);\n\n        if (rightOp) {\n          this.ptr.drop();\n          this.log(ruleName + \" succ=\", lx.keyWord, res, rightOp);\n          res = new OperatorExp_1.BinaryOpExpression(lx, res, rightOp);\n          lx = this.ptr.get();\n\n          if (lx instanceof Lexer_1.OperatorLex && accpetOperator(lx)) {\n            this.log(ruleName + \" has right \" + lx.keyWord);\n            this.ptr.push();\n            continue;\n          }\n\n          return res;\n        } else {\n          this.ptr.pop();\n          return null;\n        }\n      } else {\n        this.ptr.drop();\n        return res;\n      }\n    }\n  };\n  /**\n   * impExpression ::= eqvExpression [ { 'IMP' eqvExpression } ]\n   */\n\n\n  Parser.prototype.impExpression = function () {\n    var _this = this;\n\n    this.log('impExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.eqvExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('impExpression()', leftOp, function () {\n        return _this.eqvExpression();\n      }, function (lx) {\n        return lx.imp;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * eqvExpression ::= xorExpression [ 'EQV' xorExpression ]\n   */\n\n\n  Parser.prototype.eqvExpression = function () {\n    var _this = this;\n\n    this.log('eqvExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.xorExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('eqvExpression()', leftOp, function () {\n        return _this.xorExpression();\n      }, function (lx) {\n        return lx.eqv;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * xorExpression ::= orExpression [ { 'XOR' orExpression } ]\n   */\n\n\n  Parser.prototype.xorExpression = function () {\n    var _this = this;\n\n    this.log('xorExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.orExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('xorExpression()', leftOp, function () {\n        return _this.orExpression();\n      }, function (lx) {\n        return lx.xor;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * orExpression ::= andExpression [ { 'OR' andExpression } ]\n   */\n\n\n  Parser.prototype.orExpression = function () {\n    var _this = this;\n\n    this.log('orExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.andExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('orExpression()', leftOp, function () {\n        return _this.andExpression();\n      }, function (lx) {\n        return lx.or;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * andExpression ::= notExpression [ { 'AND' notExpression } ]\n   */\n\n\n  Parser.prototype.andExpression = function () {\n    var _this = this;\n\n    this.log('andExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.notExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('andExpression()', leftOp, function () {\n        return _this.notExpression();\n      }, function (lx) {\n        return lx.and;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * notExpression ::= ['NOT'] relationExpression\n   */\n\n\n  Parser.prototype.notExpression = function () {\n    this.log('notExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    var lx = this.ptr.get();\n\n    if (lx instanceof Lexer_1.OperatorLex && lx.not) {\n      this.ptr.push();\n      this.ptr.move(1);\n      var exp = this.relationExpression();\n\n      if (exp) {\n        this.ptr.drop();\n        return new OperatorExp_1.UnaryOpExpression(lx, exp);\n      }\n\n      this.ptr.pop();\n      return null;\n    }\n\n    return this.relationExpression();\n  };\n  /**\n   * relationExpression ::= plusExpression [ ('=', '<>', '><', '<', '>', '>=', '<=', '=>', '=<') plusExpression ]\n   */\n\n\n  Parser.prototype.relationExpression = function () {\n    this.log('relationExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.plusExpression();\n\n    if (leftOp) {\n      var lx = this.ptr.get();\n\n      if (lx instanceof Lexer_1.OperatorLex && lx.ordReleation) {\n        this.ptr.move(1);\n        var rightOp = this.plusExpression();\n\n        if (rightOp) {\n          this.ptr.drop();\n          return new OperatorExp_1.BinaryOpExpression(lx, leftOp, rightOp);\n        }\n      } else {\n        this.ptr.drop();\n        return leftOp;\n      }\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * plusExpression ::= modExpression [ { ('+' | '-') modExpression } ]\n   */\n\n\n  Parser.prototype.plusExpression = function () {\n    var _this = this;\n\n    this.log('plusExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.modExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('plusExpression()', leftOp, function () {\n        return _this.modExpression();\n      }, function (lx) {\n        return lx.plus || lx.minus;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * modExpression ::= intDivExpression [ { 'MOD' intDivExpression } ]\n   */\n\n\n  Parser.prototype.modExpression = function () {\n    var _this = this;\n\n    this.log('modExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.intDivExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('modExpression()', leftOp, function () {\n        return _this.intDivExpression();\n      }, function (lx) {\n        return lx.mod;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * intDivExpression ::= mulExpression [ { '\\' mulExpression } ]\n   */\n\n\n  Parser.prototype.intDivExpression = function () {\n    var _this = this;\n\n    this.log('intDivExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.mulExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('intDivExpression()', leftOp, function () {\n        return _this.mulExpression();\n      }, function (lx) {\n        return lx.idiv;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * mulExpression ::= powExpression [ { ( '*' | '/' ) powExpression } ]\n   */\n\n\n  Parser.prototype.mulExpression = function () {\n    var _this = this;\n\n    this.log('mulExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.powExpression();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('mulExpression()', leftOp, function () {\n        return _this.powExpression();\n      }, function (lx) {\n        return lx.mult || lx.div;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * powExpression ::= signedAtom [ { '^' signedAtom } ]\n   */\n\n\n  Parser.prototype.powExpression = function () {\n    var _this = this;\n\n    this.log('powExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var leftOp = this.signedAtom();\n\n    if (leftOp) {\n      return this.binaryRepeatExpression('powExpression()', leftOp, function () {\n        return _this.signedAtom();\n      }, function (lx) {\n        return lx.pow;\n      });\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * signedAtom ::= [ '+' | '-' ] atom\n   */\n\n\n  Parser.prototype.signedAtom = function () {\n    this.log('signedAtom() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    this.ptr.push();\n    var unary = false;\n    var unaryLx = this.ptr.get();\n\n    if (unaryLx instanceof Lexer_1.OperatorLex && (unaryLx.keyWord == '-' || unaryLx.keyWord == '+')) {\n      this.ptr.move(1);\n      unary = true;\n    }\n\n    var atom = this.atom();\n\n    if (atom) {\n      this.ptr.drop();\n\n      if (unary) {\n        return new OperatorExp_1.UnaryOpExpression(unaryLx, atom);\n      }\n\n      return atom;\n    }\n\n    this.ptr.pop();\n    return null;\n  };\n  /**\n   * atom ::= '(' expression ')'\n   *        | baseValueExpression\n   */\n\n\n  Parser.prototype.atom = function () {\n    this.log('atom() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    var leftBr = this.ptr.get(0);\n\n    if (leftBr instanceof Lexer_1.KeyWordLex && leftBr.keyWord == '(') {\n      this.ptr.push();\n      this.ptr.move(1);\n      var exp = this.expression();\n\n      if (exp) {\n        var rightBr = this.ptr.get(0);\n\n        if (rightBr instanceof Lexer_1.KeyWordLex && rightBr.keyWord == ')') {\n          this.ptr.move(1);\n          this.ptr.drop();\n          return exp;\n        }\n      }\n\n      this.ptr.pop();\n    }\n\n    return this.baseValueExpression();\n  };\n  /**\n   * baseValueExpression ::= constExpression\n   *                       | varRefExpression '(' expression [{ ',' expression }] ')'\n   *                       | varRefExpression\n   */\n\n\n  Parser.prototype.baseValueExpression = function () {\n    this.log('baseValueExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    var cexpr = this.constExpression();\n    this.log('baseValueExpression() cexpr=', cexpr);\n\n    if (cexpr) {\n      this.log('baseValueExpression() res=', cexpr);\n      return cexpr;\n    }\n\n    var vrefExp = this.varRefExpression();\n    this.log('baseValueExpression() vrefExp=', vrefExp);\n\n    if (vrefExp) {\n      this.log('baseValueExpression() res=', vrefExp);\n      var brOpen = this.ptr.get();\n\n      if (brOpen instanceof Lexer_1.OperatorLex && brOpen.arrBrOpen) {\n        var parseArrSucc = true;\n        var indexExpression = [];\n        this.ptr.push();\n        this.ptr.move(1);\n\n        while (true) {\n          var idxExp = this.expression();\n\n          if (idxExp) {\n            indexExpression.push(idxExp);\n          } else {\n            this.ptr.pop();\n            parseArrSucc = false;\n            break;\n          }\n\n          var lxNext = this.ptr.get();\n\n          if (lxNext instanceof Lexer_1.OperatorLex) {\n            if (lxNext.argDelim) {\n              this.ptr.move(1);\n              continue;\n            } else if (lxNext.arrBrClose) {\n              this.ptr.move(1);\n              break;\n            }\n          }\n        }\n\n        if (parseArrSucc) {\n          this.ptr.drop();\n          return new OperatorExp_1.VarArrIndexRef(vrefExp.id, indexExpression);\n        }\n      }\n\n      return vrefExp;\n    }\n\n    return null;\n  };\n  /**\n   * constExpression ::= NumberLex | StringLex\n   */\n\n\n  Parser.prototype.constExpression = function () {\n    this.log('constExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    var lx = this.ptr.get();\n\n    if (lx instanceof Lexer_1.NumberLex) {\n      this.ptr.move(1);\n      return new OperatorExp_1.LiteralExpression(lx, lx.value);\n    }\n\n    if (lx instanceof Lexer_1.StringLex) {\n      this.ptr.move(1);\n      return new OperatorExp_1.LiteralExpression(lx, lx.value);\n    }\n\n    return null;\n  };\n  /**\n   * varRefExpression ::= IDLex\n   */\n\n\n  Parser.prototype.varRefExpression = function () {\n    this.log('varRefExpression() ptr=', this.ptr.gets(3));\n    if (this.ptr.eof) return null;\n    var lx = this.ptr.get();\n    this.log('varRefExpression() lx=', lx);\n\n    if (lx instanceof Lexer_1.IDLex) {\n      this.log('varRefExpression() succ', lx);\n      this.ptr.move(1);\n      return new OperatorExp_1.VarRefExpression(lx);\n    }\n\n    return null;\n  };\n\n  return Parser;\n}();\n\nexports.Parser = Parser;\n\n//# sourceURL=webpack:///./out/ts/ast/Parser.js?");

/***/ }),

/***/ "./out/ts/ast/Pointer.js":
/*!*******************************!*\
  !*** ./out/ts/ast/Pointer.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Num_1 = __webpack_require__(/*! ../Num */ \"./out/ts/Num.js\");\n/**\n * Перемещаемый указатель по массиву\n */\n\n\nvar Pointer =\n/** @class */\nfunction () {\n  /**\n   * Конструктор\n   * @param entries текст\n   */\n  function Pointer(entries) {\n    /**\n     * Сохраненный стек указателей\n     */\n    this.stack = [];\n    this.pointerValue = 0;\n    this.entries = entries;\n  }\n\n  Object.defineProperty(Pointer.prototype, \"ptr\", {\n    /**\n     * Возвращает указатель\n     */\n    get: function get() {\n      return this.pointerValue;\n    },\n\n    /**\n     * Устанавливает текущий казатель\n     */\n    set: function set(v) {\n      this.pointerValue = Num_1.asInt(v);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Pointer.prototype, \"eof\", {\n    /**\n     * Возвращает прзнак что указать достигнул конец списка элементов\n     */\n    get: function get() {\n      return this.ptr >= this.entries.length;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Смещение указателя на указанное число элементов\n   * @param n число элементов\n   */\n\n  Pointer.prototype.move = function (n) {\n    this.pointerValue += Num_1.asInt(n);\n    return this.pointerValue;\n  };\n  /**\n   * Сохранение текущего указателя в стеке\n   */\n\n\n  Pointer.prototype.push = function () {\n    this.stack.push(this.ptr);\n  };\n  /**\n   * Чтение сохраненного указателя из стека\n   */\n\n\n  Pointer.prototype.peek = function () {\n    if (this.stack.length <= 0) return null;\n    return this.stack[this.stack.length - 1];\n  };\n  /**\n   * Восстановление текущего указатель из стека с удалением значения из стека\n   */\n\n\n  Pointer.prototype.pop = function () {\n    if (this.stack.length <= 0) throw new Error(\"stack is empty\");\n    var v = this.stack.pop();\n\n    if (v !== undefined) {\n      this.ptr = v;\n    }\n\n    return this.ptr;\n  };\n  /**\n   * Удаление верхнего элемента стека без восстановления указателя\n   */\n\n\n  Pointer.prototype.drop = function () {\n    if (this.stack.length <= 0) throw new Error(\"stack is empty\");\n    this.stack.pop();\n    return this.ptr;\n  };\n  /**\n   * Полчение значения\n   * @param off смещение от текущей позиции\n   */\n\n\n  Pointer.prototype.get = function (off) {\n    if (off === void 0) {\n      off = 0;\n    }\n\n    var t = this.ptr + off;\n\n    if (t >= 0 && t < this.entries.length) {\n      return this.entries[t];\n    }\n\n    return null;\n  };\n  /**\n   * Получение массива значений\n   * @param off смещение от текущей позиции\n   * @param cnt максимальное кол-во значений\n   */\n\n\n  Pointer.prototype.fetch = function (off, cnt) {\n    if (off === void 0) {\n      off = 0;\n    }\n\n    if (cnt === void 0) {\n      cnt = 1;\n    }\n\n    var res = [];\n    var start = this.ptr + off;\n    if (cnt <= 0) return res;\n\n    for (var i = 0; i < cnt; i++) {\n      var ti = start + i;\n\n      if (ti >= 0 && ti < this.entries.length) {\n        res.push(this.entries[ti]);\n      }\n    }\n\n    return res;\n  };\n  /**\n   * Получение массива значений\n   * @param cnt максимальное кол-во значений\n   */\n\n\n  Pointer.prototype.gets = function (cnt) {\n    if (cnt === void 0) {\n      cnt = 1;\n    }\n\n    return this.fetch(0, cnt);\n  };\n\n  return Pointer;\n}();\n\nexports.Pointer = Pointer;\n\n//# sourceURL=webpack:///./out/ts/ast/Pointer.js?");

/***/ }),

/***/ "./out/ts/ast/PrintStatement.js":
/*!**************************************!*\
  !*** ./out/ts/ast/PrintStatement.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar PrintStatement =\n/** @class */\nfunction (_super) {\n  __extends(PrintStatement, _super);\n\n  function PrintStatement(begin, end, print, args) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.print = print;\n    _this.args = args;\n    _this.kind = 'Print';\n    return _this;\n  }\n\n  return PrintStatement;\n}(Statement_1.Statement);\n\nexports.PrintStatement = PrintStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/PrintStatement.js?");

/***/ }),

/***/ "./out/ts/ast/RemStatement.js":
/*!************************************!*\
  !*** ./out/ts/ast/RemStatement.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar RemStatement =\n/** @class */\nfunction (_super) {\n  __extends(RemStatement, _super);\n\n  function RemStatement(begin, end, rem) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.rem = rem;\n    _this.kind = 'Rem';\n    return _this;\n  }\n\n  return RemStatement;\n}(Statement_1.Statement);\n\nexports.RemStatement = RemStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/RemStatement.js?");

/***/ }),

/***/ "./out/ts/ast/ReturnStatement.js":
/*!***************************************!*\
  !*** ./out/ts/ast/ReturnStatement.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar ReturnStatement =\n/** @class */\nfunction (_super) {\n  __extends(ReturnStatement, _super);\n\n  function ReturnStatement(begin, end, line) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.gotoLine = line;\n    _this.kind = 'Return';\n    return _this;\n  }\n\n  return ReturnStatement;\n}(Statement_1.Statement);\n\nexports.ReturnStatement = ReturnStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/ReturnStatement.js?");

/***/ }),

/***/ "./out/ts/ast/RunStatement.js":
/*!************************************!*\
  !*** ./out/ts/ast/RunStatement.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar RunStatement =\n/** @class */\nfunction (_super) {\n  __extends(RunStatement, _super);\n\n  function RunStatement(begin, end, line) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.runLine = line;\n    _this.kind = 'Run';\n    return _this;\n  }\n\n  return RunStatement;\n}(Statement_1.Statement);\n\nexports.RunStatement = RunStatement;\n\n//# sourceURL=webpack:///./out/ts/ast/RunStatement.js?");

/***/ }),

/***/ "./out/ts/ast/Statement.js":
/*!*********************************!*\
  !*** ./out/ts/ast/Statement.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Lexer_1 = __webpack_require__(/*! ./Lexer */ \"./out/ts/ast/Lexer.js\");\n/**\n * Некий кусок кода, который по традиции должен умещаться в одной строке\n */\n\n\nvar Statement =\n/** @class */\nfunction () {\n  function Statement() {}\n\n  Object.defineProperty(Statement.prototype, \"sourceLine\", {\n    /**\n     * Номер строки\n     */\n    get: function get() {\n      if (this.begin instanceof Lexer_1.SourceLineBeginLex) {\n        return this.begin.line;\n      }\n\n      return undefined;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Statement;\n}();\n\nexports.Statement = Statement;\n\n//# sourceURL=webpack:///./out/ts/ast/Statement.js?");

/***/ }),

/***/ "./out/ts/ast/Statements.js":
/*!**********************************!*\
  !*** ./out/ts/ast/Statements.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Statement_1 = __webpack_require__(/*! ./Statement */ \"./out/ts/ast/Statement.js\");\n\nvar Statements =\n/** @class */\nfunction (_super) {\n  __extends(Statements, _super);\n\n  function Statements(begin, end, statements) {\n    var _this = _super.call(this) || this;\n\n    _this.begin = begin;\n    _this.end = end;\n    _this.statements = statements;\n    return _this;\n  }\n\n  return Statements;\n}(Statement_1.Statement);\n\nexports.Statements = Statements;\n\n//# sourceURL=webpack:///./out/ts/ast/Statements.js?");

/***/ }),

/***/ "./out/ts/hello.js":
/*!*************************!*\
  !*** ./out/ts/hello.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar wu = __importStar(__webpack_require__(/*! ./WidgetUtil */ \"./out/ts/WidgetUtil.js\"));\n\nvar SourceUnit_1 = __webpack_require__(/*! ./vm/SourceUnit */ \"./out/ts/vm/SourceUnit.js\");\n\nvar AstToBasic_1 = __webpack_require__(/*! ./ast/AstToBasic */ \"./out/ts/ast/AstToBasic.js\");\n\nvar Memo_1 = __webpack_require__(/*! ./vm/Memo */ \"./out/ts/vm/Memo.js\");\n\nvar BasicVm_1 = __webpack_require__(/*! ./vm/BasicVm */ \"./out/ts/vm/BasicVm.js\");\n\nvar GWBASICApp =\n/** @class */\nfunction () {\n  function GWBASICApp() {\n    //#endregion\n    //#region sourceUnit\n    this.suValue = new SourceUnit_1.SourceUnit();\n    this.renderedSourceLines = {}; //#endregion\n    //#region memo\n\n    this.memoInstance = new Memo_1.Memo();\n    this.uiVars = {};\n  }\n\n  Object.defineProperty(GWBASICApp.prototype, \"ui\", {\n    //#region ui\n    get: function get() {\n      return {\n        get sourceUnit() {\n          return document.querySelector('#sourceUnit');\n        },\n\n        get sourceCode() {\n          return document.querySelector('#sourceCode');\n        },\n\n        get parseSourceCode() {\n          return document.querySelector('#parseSourceCode');\n        },\n\n        get parseError() {\n          return document.querySelector('#parseError');\n        },\n\n        get goNext() {\n          return document.querySelector('#goNext');\n        },\n\n        get memoDump() {\n          return document.querySelector('#memoDump');\n        },\n\n        get helpContent() {\n          return document.querySelector('#helpContent');\n        },\n\n        get showHelp() {\n          return document.querySelector('#showHelp');\n        },\n\n        get closeHelp() {\n          return document.querySelector('#closeHelp');\n        }\n\n      };\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(GWBASICApp.prototype, \"sourceUnit\", {\n    get: function get() {\n      return this.suValue;\n    },\n    set: function set(su) {\n      var _this = this;\n\n      this.suValue = su;\n      setTimeout(function () {\n        _this.renderSourceUnit();\n      }, 1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GWBASICApp.prototype.parseBasic = function (command) {\n    try {\n      var imStmts_2 = [];\n      this.sourceUnit = this.sourceUnit.parse(command, {\n        immediateStatements: function immediateStatements(statements) {\n          imStmts_2 = statements;\n        }\n      });\n      this.rebuildVm();\n\n      if (this.ui.parseError) {\n        this.ui.parseError.innerHTML = '';\n        this.ui.parseError.style.display = 'none';\n      }\n\n      for (var _i = 0, imStmts_1 = imStmts_2; _i < imStmts_1.length; _i++) {\n        var imSt = imStmts_1[_i];\n        this.vm.evalStatement(imSt);\n      }\n    } catch (err) {\n      if (this.ui.parseError) {\n        this.ui.parseError.textContent = err.toString();\n        this.ui.parseError.style.display = '';\n        console.log('log parse error:', err.toString());\n      } else {\n        console.log('log parse error:', err.toString());\n      }\n    }\n  };\n\n  GWBASICApp.prototype.renderSourceUnit = function () {\n    var _this = this;\n\n    this.renderedSourceLines = {};\n\n    if (this.ui.sourceUnit) {\n      var ui = this.ui.sourceUnit;\n      ui.innerHTML = '';\n\n      var _loop_1 = function _loop_1(line) {\n        var ldiv = wu.div({\n          \"class\": \"sourceLine l\" + line.line + \" li\" + line.index\n        }).append(ui).el;\n        wu.span({\n          \"class\": \"lineNum\"\n        }).text(line.line.toString()).append(ldiv);\n        wu.span({\n          \"class\": 'code'\n        }).text(AstToBasic_1.astToBasic(line.statement, {\n          sourceLineNumber: false\n        })).append(ldiv);\n        wu.a({\n          \"class\": 'goto',\n          href: '#'\n        }).text('goto').append(ldiv).onclick(function (e) {\n          _this[\"goto\"](line.index);\n        });\n        this_1.renderedSourceLines[line.index] = ldiv;\n\n        if (this_1.vm.ip == line.index) {\n          ldiv.classList.add('active');\n        }\n      };\n\n      var this_1 = this;\n\n      for (var _i = 0, _a = this.sourceUnit.lines; _i < _a.length; _i++) {\n        var line = _a[_i];\n\n        _loop_1(line);\n      }\n    }\n  };\n\n  Object.defineProperty(GWBASICApp.prototype, \"memo\", {\n    get: function get() {\n      var _this = this;\n\n      if (this.memoInstance) return this.memoInstance;\n      this.memoInstance = new Memo_1.Memo();\n      setTimeout(function () {\n        _this.renderMemo();\n      }, 1);\n      return this.memoInstance;\n    },\n    set: function set(mem) {\n      var _this = this;\n\n      this.memoInstance = mem;\n      setTimeout(function () {\n        _this.renderMemo();\n      }, 1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GWBASICApp.prototype.renderMemo = function () {\n    if (this.ui.memoDump) {\n      this.ui.memoDump.innerHTML = '';\n\n      for (var _i = 0, _a = this.memo.varnames; _i < _a.length; _i++) {\n        var varname = _a[_i];\n        var varvalue = this.memo.read(varname);\n      }\n    }\n  };\n\n  GWBASICApp.prototype.renderMemoVar = function (varname, oldvalue, newvalue) {\n    if (newvalue != undefined) {\n      var ui = this.uiVars[varname];\n\n      if (ui) {\n        ui.value.innerText = newvalue;\n      } else {\n        ui = {\n          container: wu.div({\n            \"class\": 'var'\n          }).el,\n          name: wu.span({\n            \"class\": 'name'\n          }).text(varname).el,\n          value: wu.span({\n            \"class\": 'value'\n          }).text(newvalue).el\n        };\n        ui.container.appendChild(ui.name);\n        ui.container.appendChild(ui.value);\n        this.uiVars[varname] = ui;\n\n        if (this.ui.memoDump) {\n          this.ui.memoDump.appendChild(ui.container);\n        }\n      }\n    }\n  };\n\n  Object.defineProperty(GWBASICApp.prototype, \"vm\", {\n    get: function get() {\n      var _this = this;\n\n      if (this.vmInstance) return this.vmInstance;\n      this.vmInstance = new BasicVm_1.BasicVm(this.sourceUnit, this.memo);\n      setTimeout(function () {\n        _this.renderVm();\n      }, 1);\n      return this.vmInstance;\n    },\n    set: function set(v) {\n      var _this = this;\n\n      this.vmInstance = v;\n      setTimeout(function () {\n        _this.renderVm();\n      }, 1);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  GWBASICApp.prototype.rebuildVm = function () {\n    var _this = this;\n\n    this.vmInstance = new BasicVm_1.BasicVm(this.sourceUnit, this.memo);\n    setTimeout(function () {\n      _this.renderVm();\n    }, 1);\n    return this.vmInstance;\n  };\n\n  GWBASICApp.prototype.renderVm = function () {\n    this.renderIp();\n  }; //#endregion\n  //#region goto/renderIp\n\n\n  GWBASICApp.prototype[\"goto\"] = function (ip) {\n    var _this = this;\n\n    console.log(\"goto ip=\" + ip);\n    this.vm.ip = ip;\n    setTimeout(function () {\n      _this.renderIp();\n    }, 1);\n  };\n\n  GWBASICApp.prototype.renderIp = function () {\n    for (var i = 0; i < Object.getOwnPropertyNames(this.renderedSourceLines).length; i++) {\n      this.renderedSourceLines[i].classList.remove('active');\n    }\n\n    var lineDiv = this.renderedSourceLines[this.vm.ip];\n\n    if (lineDiv) {\n      lineDiv.classList.add('active');\n    }\n  }; //#endregion\n  //#region goNext\n\n\n  GWBASICApp.prototype.goNext = function () {\n    console.log('goNext() clicked');\n\n    if (this.vm.hasNext()) {\n      this.vm.next();\n      this.renderIp();\n    }\n  }; //#endregion\n\n\n  GWBASICApp.prototype.init = function () {\n    var _this = this;\n\n    if (this.ui.parseSourceCode && this.ui.sourceCode) {\n      var btn = this.ui.parseSourceCode;\n      var txt_1 = this.ui.sourceCode;\n      btn.addEventListener('click', function (e) {\n        return _this.parseBasic(txt_1.value);\n      });\n      txt_1.addEventListener('keydown', function (e) {\n        if (e.keyCode == 13 && e.ctrlKey) {\n          _this.parseBasic(txt_1.value);\n        } else if (e.code == 'KeyN' && e.altKey) {\n          _this.goNext();\n        } else {//console.log('keydown',e)\n        }\n      });\n    }\n\n    if (this.ui.goNext) {\n      this.ui.goNext.addEventListener('click', function (e) {\n        return _this.goNext();\n      });\n    }\n\n    this.memo.listeners.push(function (varname, from, to) {\n      console.log('handled var changes ', varname, from, to);\n\n      _this.renderMemoVar(varname, from, to);\n    });\n\n    if (this.ui.showHelp) {\n      this.ui.showHelp.addEventListener('click', function (e) {\n        if (_this.ui.helpContent) {\n          _this.ui.helpContent.classList.add('active');\n\n          console.log(\"clicked 1\");\n        }\n      });\n    }\n\n    if (this.ui.closeHelp) {\n      this.ui.closeHelp.addEventListener('click', function (e) {\n        if (_this.ui.helpContent) {\n          _this.ui.helpContent.classList.remove('active');\n\n          console.log(\"clicked 2\");\n        }\n      });\n    }\n  };\n\n  return GWBASICApp;\n}();\n\nnew GWBASICApp().init();\n\n//# sourceURL=webpack:///./out/ts/hello.js?");

/***/ }),

/***/ "./out/ts/vm/BasicVm.js":
/*!******************************!*\
  !*** ./out/ts/vm/BasicVm.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar LetStatement_1 = __webpack_require__(/*! ../ast/LetStatement */ \"./out/ts/ast/LetStatement.js\");\n\nvar OperatorExp_1 = __webpack_require__(/*! ../ast/OperatorExp */ \"./out/ts/ast/OperatorExp.js\");\n\nvar Memo_1 = __webpack_require__(/*! ./Memo */ \"./out/ts/vm/Memo.js\");\n\nvar Num_1 = __webpack_require__(/*! ../Num */ \"./out/ts/Num.js\");\n\nvar RemStatement_1 = __webpack_require__(/*! ../ast/RemStatement */ \"./out/ts/ast/RemStatement.js\");\n\nvar RunStatement_1 = __webpack_require__(/*! ../ast/RunStatement */ \"./out/ts/ast/RunStatement.js\");\n\nvar GotoStatement_1 = __webpack_require__(/*! ../ast/GotoStatement */ \"./out/ts/ast/GotoStatement.js\");\n\nvar IfStatement_1 = __webpack_require__(/*! ../ast/IfStatement */ \"./out/ts/ast/IfStatement.js\");\n\nvar GoSubStatement_1 = __webpack_require__(/*! ../ast/GoSubStatement */ \"./out/ts/ast/GoSubStatement.js\");\n\nvar ReturnStatement_1 = __webpack_require__(/*! ../ast/ReturnStatement */ \"./out/ts/ast/ReturnStatement.js\");\n\nvar PrintStatement_1 = __webpack_require__(/*! ../ast/PrintStatement */ \"./out/ts/ast/PrintStatement.js\");\n\nvar Printer_1 = __webpack_require__(/*! ./Printer */ \"./out/ts/vm/Printer.js\");\n\nvar BasicVm =\n/** @class */\nfunction () {\n  function BasicVm(source, memo) {\n    this._printer = this.defaultPrinter;\n    /**\n     * Стек вызовов GoSub\n     */\n\n    this.ipStack = [];\n    /**\n     * Регистр IP (Instruction Pointer)\n     */\n\n    this.ip = -1;\n    this.source = source;\n\n    if (memo) {\n      this.memo = memo;\n    } else {\n      this.memo = new Memo_1.Memo();\n    }\n  }\n  /**\n   * Вычисляет выражение (expression)\n   * @param exp выражение\n   */\n\n\n  BasicVm.prototype.evalExpression = function (exp) {\n    if (exp instanceof OperatorExp_1.LiteralExpression) {\n      return exp.value;\n    }\n\n    if (exp instanceof OperatorExp_1.VarRefExpression) {\n      var res = this.memo.read(exp.varname);\n      if (res == undefined) throw new Error(\"undefined variable \" + exp.varname);\n      return res;\n    }\n\n    if (exp instanceof OperatorExp_1.UnaryOpExpression) {\n      if (exp.operator.minus) return 0 - this.evalExpression(exp.base);\n      if (exp.operator.plus) return this.evalExpression(exp.base);\n      if (exp.operator.not) return !this.evalExpression(exp.base);\n      throw new Error(\"undefined unary operator \" + exp.operator.keyWord);\n    }\n\n    if (exp instanceof OperatorExp_1.BinaryOpExpression) {\n      //#region math\n      if (exp.operator.plus) return this.evalExpression(exp.left) + this.evalExpression(exp.right);\n      if (exp.operator.minus) return this.evalExpression(exp.left) - this.evalExpression(exp.right);\n      if (exp.operator.mult) return this.evalExpression(exp.left) * this.evalExpression(exp.right);\n      if (exp.operator.div) return this.evalExpression(exp.left) / this.evalExpression(exp.right);\n      if (exp.operator.idiv) return Num_1.asInt(this.evalExpression(exp.left) / Num_1.asInt(this.evalExpression(exp.right)));\n      if (exp.operator.mod) return Num_1.asInt(this.evalExpression(exp.left) % this.evalExpression(exp.right)); //#endregion\n      //#region logic\n\n      if (exp.operator.and) return this.evalExpression(exp.left) && this.evalExpression(exp.right);\n      if (exp.operator.or) return this.evalExpression(exp.left) || this.evalExpression(exp.right); // TODO check type\n\n      if (exp.operator.xor) return !(this.evalExpression(exp.left) == this.evalExpression(exp.right)); // TODO check type\n\n      if (exp.operator.eqv) return this.evalExpression(exp.left) == this.evalExpression(exp.right);\n\n      if (exp.operator.imp) {\n        var l = this.evalExpression(exp.left);\n        var r = this.evalExpression(exp.right);\n\n        if (l) {\n          if (r) {\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          return true;\n        }\n      } //#endregion\n      //#region compare\n\n\n      if (exp.operator.equals) {\n        return this.evalExpression(exp.left) == this.evalExpression(exp.right);\n      }\n\n      if (exp.operator.notEquals) {\n        return this.evalExpression(exp.left) != this.evalExpression(exp.right);\n      }\n\n      if (exp.operator.less) {\n        return this.evalExpression(exp.left) < this.evalExpression(exp.right);\n      }\n\n      if (exp.operator.lesOrEquals) {\n        return this.evalExpression(exp.left) <= this.evalExpression(exp.right);\n      }\n\n      if (exp.operator.more) {\n        return this.evalExpression(exp.left) > this.evalExpression(exp.right);\n      }\n\n      if (exp.operator.moreOrEquals) {\n        return this.evalExpression(exp.left) >= this.evalExpression(exp.right);\n      } //#endregion\n\n\n      throw new Error(\"undefined binary operator \" + exp.operator.keyWord);\n    }\n\n    throw new Error(\"undefined expression \" + exp);\n  };\n\n  Object.defineProperty(BasicVm.prototype, \"defaultPrinter\", {\n    get: function get() {\n      return Printer_1.printers.console.clone().configure(function (c) {\n        c.prefix = \"BASIC> \";\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BasicVm.prototype, \"printer\", {\n    get: function get() {\n      return this._printer;\n    },\n    set: function set(x) {\n      if (x) {\n        this._printer = x;\n      } else {\n        this._printer = this.defaultPrinter;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BasicVm.prototype.print = function (v) {\n    this.printer.print(v);\n  };\n\n  BasicVm.prototype.println = function () {\n    this.printer.println();\n  };\n  /**\n   * Выполняет выражение (statement)\n   * @param st выражение\n   */\n\n\n  BasicVm.prototype.evalStatement = function (st) {\n    var _this = this;\n\n    if (st instanceof RemStatement_1.RemStatement) {\n      return;\n    }\n\n    if (st instanceof LetStatement_1.LetStatement) {\n      var val = this.evalExpression(st.value);\n      this.memo.write(st.varname, val);\n      return;\n    }\n\n    if (st instanceof RunStatement_1.RunStatement) {\n      return;\n    }\n\n    if (st instanceof GotoStatement_1.GotoStatement) {\n      var found = this.source.find(st.gotoLine.value);\n\n      if (found) {\n        this.ip = found.index;\n      } else {\n        throw new Error(\"source line \" + st.gotoLine.value + \" not found\");\n      }\n\n      return;\n    }\n\n    if (st instanceof GoSubStatement_1.GoSubStatement) {\n      var found = this.source.find(st.gotoLine.value);\n\n      if (found) {\n        //console.log(\"gosub \",found)\n        this.ipStack.push(this.ip);\n        this.ip = found.index;\n      } else {\n        throw new Error(\"source line \" + st.gotoLine.value + \" not found\");\n      }\n    }\n\n    if (st instanceof ReturnStatement_1.ReturnStatement) {\n      if (st.gotoLine) {\n        var found = this.source.find(st.gotoLine.value);\n\n        if (found) {\n          this.ipStack.pop();\n          this.ip = found.index;\n        } else {\n          throw new Error(\"source line \" + st.gotoLine.value + \" not found\");\n        }\n      } else {\n        if (this.ipStack.length > 0) {\n          var targetIp = this.ipStack.pop();\n\n          if (targetIp !== undefined) {\n            this.ip = targetIp + 1;\n          } else {\n            throw new Error(\"gosub stack return undefined\");\n          }\n        } else {\n          throw new Error(\"gosub stack is empty\");\n        }\n      }\n    }\n\n    if (st instanceof IfStatement_1.IfStatement) {\n      var bval = this.evalExpression(st.boolExp);\n\n      if (bval) {\n        this.evalStatement(st.trueStatement);\n      } else if (st.falseStatement) {\n        this.evalStatement(st.falseStatement);\n      }\n    }\n\n    if (st instanceof PrintStatement_1.PrintStatement) {\n      st.args.forEach(function (exp) {\n        var v = _this.evalExpression(exp);\n\n        _this.print(v);\n      });\n      this.println();\n    }\n  };\n  /**\n   * Проверяет есть ли еще инструкции для выполнения\n   * @returns true - есть инструкции для выполенения\n   */\n\n\n  BasicVm.prototype.hasNext = function () {\n    if (this.ip < 0) return false;\n    if (this.ip >= this.source.lines.length) return false;\n    return true;\n  };\n  /**\n   * Выполняет очередную инструкцию\n   * @returns true - инструкция выполнена / false - инструкция не была выполнена ибо конец\n   */\n\n\n  BasicVm.prototype.next = function () {\n    if (!this.hasNext()) return false;\n    var st = this.source.lines[this.ip];\n    if (st == undefined || st == null) return false;\n    var beforeIp = this.ip;\n    this.evalStatement(st.statement);\n    var afterIp = this.ip;\n\n    if (afterIp == beforeIp) {\n      this.ip++;\n    }\n\n    return true;\n  };\n\n  return BasicVm;\n}();\n\nexports.BasicVm = BasicVm;\n\n//# sourceURL=webpack:///./out/ts/vm/BasicVm.js?");

/***/ }),

/***/ "./out/ts/vm/Memo.js":
/*!***************************!*\
  !*** ./out/ts/vm/Memo.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Память VM\n */\n\nvar Memo =\n/** @class */\nfunction () {\n  function Memo() {\n    /**\n     * Непочредственно значния\n     */\n    this.values = {};\n    /**\n     * Подписчики на изменения значений памяти VM\n     */\n\n    this.listeners = [];\n  }\n  /**\n   * Чтение значения\n   * @param varname имя переменной\n   */\n\n\n  Memo.prototype.read = function (varname, indexes) {\n    var v = this.values[varname];\n\n    if (indexes) {\n      var arr = [];\n\n      for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {\n        var a = indexes_1[_i];\n        arr.push(a);\n      }\n\n      while (indexes.length > 0) {\n        var idx = indexes[0];\n        indexes.splice(0, 1);\n\n        if (v instanceof Object || v instanceof Array) {\n          v = v[idx];\n        } else {\n          v = undefined;\n          break;\n        }\n      }\n\n      console.log(\"debug read var \" + varname + \"[\" + arr + \"] = \" + v);\n      return v;\n    }\n\n    return v;\n  };\n  /**\n   * Запись значения памяти\n   * @param varname имя переменной\n   * @param value значение переменной\n   */\n\n\n  Memo.prototype.write = function (varname, value, indexes) {\n    var aindexes = [];\n\n    if (indexes) {\n      for (var _i = 0, indexes_2 = indexes; _i < indexes_2.length; _i++) {\n        var a = indexes_2[_i];\n        aindexes.push(a);\n      }\n    }\n\n    if (indexes) {\n      var arr = [];\n\n      if (this.values[varname] instanceof Array || this.values[varname] instanceof Object) {\n        arr = this.values[varname];\n        console.log(\"resolved \" + varname + \" as []\");\n      } else {\n        this.values[varname] = arr;\n        console.log(\"assign \" + varname + \" = []\");\n      }\n\n      while (indexes.length > 1) {\n        var idx = indexes[0];\n        indexes.splice(0, 1);\n\n        if (arr[idx] instanceof Object || arr[idx] instanceof Array) {\n          arr = arr[idx];\n          console.log(\"resolved [\" + idx + \"] as \" + _typeof(arr));\n        } else {\n          arr[idx] = [];\n          arr = arr[idx];\n          console.log(\"assign [\" + idx + \"] = []\");\n        }\n      }\n\n      var old_1 = undefined;\n\n      if (indexes.length == 1) {\n        var idx = indexes[0];\n        old_1 = arr[idx];\n        arr[idx] = value;\n        console.log(\"assign [\" + idx + \"] = \" + value);\n      }\n\n      for (var _a = 0, _b = this.listeners; _a < _b.length; _a++) {\n        var ls = _b[_a];\n        ls(varname, old_1, value, aindexes);\n      }\n\n      return;\n    }\n\n    console.log(\"debug write var \" + varname + \" = \" + value);\n    var old = this.values[varname];\n    this.values[varname] = value;\n\n    for (var _c = 0, _d = this.listeners; _c < _d.length; _c++) {\n      var ls = _d[_c];\n      ls(varname, old, value);\n    }\n  };\n\n  Object.defineProperty(Memo.prototype, \"varnames\", {\n    get: function get() {\n      return Object.keys(this.values);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Memo;\n}();\n\nexports.Memo = Memo;\n\n//# sourceURL=webpack:///./out/ts/vm/Memo.js?");

/***/ }),

/***/ "./out/ts/vm/Printer.js":
/*!******************************!*\
  !*** ./out/ts/vm/Printer.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ConsolePrinter =\n/** @class */\nfunction () {\n  function ConsolePrinter() {\n    this.args = [];\n    this.prefix = \"\";\n  }\n\n  ConsolePrinter.prototype.clone = function () {\n    var c = new ConsolePrinter();\n    c.args = this.args;\n    c.prefix = this.prefix;\n    return c;\n  };\n\n  ConsolePrinter.prototype.configure = function (x) {\n    x(this);\n    return this;\n  };\n\n  ConsolePrinter.prototype.print = function (value) {\n    this.args.push(value);\n  };\n\n  ConsolePrinter.prototype.println = function () {\n    console.log(this.prefix + this.args.map(function (x) {\n      return \"\" + x;\n    }).join(\"\"));\n    this.args = [];\n  };\n\n  return ConsolePrinter;\n}();\n\nexports.ConsolePrinter = ConsolePrinter;\n\nvar CustomPrinter =\n/** @class */\nfunction () {\n  function CustomPrinter(printfn, printlnfn) {\n    this.printfn = printfn;\n    this.printlnfn = printlnfn;\n  }\n\n  CustomPrinter.prototype.print = function (value) {\n    this.printfn(value);\n  };\n\n  CustomPrinter.prototype.println = function () {\n    this.printlnfn();\n  };\n\n  return CustomPrinter;\n}();\n\nexports.CustomPrinter = CustomPrinter;\n\nvar SingleFnPrinter =\n/** @class */\nfunction () {\n  function SingleFnPrinter(printfn) {\n    this.args = [];\n    this.printfn = printfn;\n  }\n\n  SingleFnPrinter.prototype.print = function (value) {\n    this.args.push(value);\n  };\n\n  SingleFnPrinter.prototype.println = function () {\n    this.printfn(this.args);\n    this.args = [];\n  };\n\n  return SingleFnPrinter;\n}();\n\nexports.SingleFnPrinter = SingleFnPrinter;\nexports.printers = {\n  console: new ConsolePrinter(),\n  custom: function custom(printfn, printlnfn) {\n    return new CustomPrinter(printfn, printlnfn);\n  },\n  sprint: function sprint(printfn) {\n    return new SingleFnPrinter(printfn);\n  }\n};\n\n//# sourceURL=webpack:///./out/ts/vm/Printer.js?");

/***/ }),

/***/ "./out/ts/vm/SourceUnit.js":
/*!*********************************!*\
  !*** ./out/ts/vm/SourceUnit.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Parser_1 = __webpack_require__(/*! ../ast/Parser */ \"./out/ts/ast/Parser.js\");\n/**\n * Исходная строка\n */\n\n\nvar SourceLine =\n/** @class */\nfunction () {\n  function SourceLine(line, code) {\n    this.line = line;\n    this.statement = code;\n  }\n\n  return SourceLine;\n}();\n\nexports.SourceLine = SourceLine;\n/**\n * Исходный текст\n */\n\nvar SourceUnit =\n/** @class */\nfunction () {\n  /**\n   * Конструктор\n   * @param sample образец для копирования\n   */\n  function SourceUnit(sample) {\n    /**\n     * Набор строк исхдного текста\n     */\n    this.sourceLines = []; //#region lines : IDXSourceLine\n\n    this.linesCache = null;\n\n    if (sample) {\n      for (var li in sample.sourceLines) {\n        this.sourceLines[li] = sample.sourceLines[li];\n      }\n    }\n  }\n\n  Object.defineProperty(SourceUnit.prototype, \"lines\", {\n    /**\n     * Возвращает список исходных строк\n     */\n    get: function get() {\n      if (this.linesCache) return this.linesCache;\n      var lines = [];\n      var idx = -1;\n\n      for (var _i = 0, _a = this.sourceLines; _i < _a.length; _i++) {\n        var sl = _a[_i];\n        idx++;\n        lines.push({\n          statement: sl.statement,\n          index: idx,\n          line: sl.line\n        });\n      }\n\n      this.linesCache = Object.freeze(lines);\n      return this.linesCache;\n    },\n    enumerable: true,\n    configurable: true\n  }); //#endregion\n\n  /**\n   * Возвращает исходную строку (номер, строка / индекс) по ее номеру\n   * @param line номер строки\n   */\n\n  SourceUnit.prototype.find = function (line) {\n    if (line < 0) return null;\n\n    for (var i in this.sourceLines) {\n      var sline = this.sourceLines[i];\n\n      if (sline.line == line) {\n        return {\n          statement: sline.statement,\n          index: parseInt(i),\n          line: sline.line\n        };\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Возвращает исходную строку (номер, строка / индекс) по ее номеру\n   * @param line номер строки\n   */\n\n\n  SourceUnit.prototype.line = function (line) {\n    var res = this.find(line);\n    if (res) return res;\n    throw new Error(\"source line with number \" + line + \" not found\");\n  };\n  /**\n   * Добавляет строку и возвращает новый объект исходного когда\n   * @param line номер строки\n   * @param code код\n   * @returns модифицированный исходный код\n   */\n\n\n  SourceUnit.prototype.set = function (line, code) {\n    if (line < 0) throw new Error(\"argument line(=\" + line + \") < 0\");\n    var fnd = this.find(line);\n\n    if (fnd) {\n      var cln_1 = new SourceUnit(this);\n      cln_1.sourceLines[fnd.index] = new SourceLine(line, code);\n      return cln_1;\n    }\n\n    var cln = new SourceUnit(this);\n    cln.sourceLines.push(new SourceLine(line, code));\n    cln.sourceLines = cln.sourceLines.sort(function (a, b) {\n      return a.line - b.line;\n    });\n    return cln;\n  };\n  /**\n   * Парсинг исходного текста\n   * @param source исходный текст\n   * @param presult результат парсинга\n   */\n\n\n  SourceUnit.prototype.parse = function (source, presult) {\n    if (source) {\n      var parser = Parser_1.Parser.create(source);\n      var stmts = parser.statements();\n      var res = this;\n\n      if (stmts) {\n        var sstmts = [];\n        var istmts = [];\n\n        if (presult && presult.statments) {\n          presult.statments(stmts);\n        }\n\n        for (var _i = 0, _a = stmts.statements; _i < _a.length; _i++) {\n          var st = _a[_i];\n\n          if (st.sourceLine) {\n            res = res.set(st.sourceLine, st);\n            sstmts.push(st);\n          } else {\n            istmts.push(st);\n          }\n        }\n\n        if (presult && presult.sources) {\n          presult.sources(sstmts);\n        }\n\n        if (presult && presult.immediateStatements) {\n          presult.immediateStatements(istmts);\n        }\n      }\n\n      return res;\n    }\n\n    return this;\n  };\n\n  return SourceUnit;\n}();\n\nexports.SourceUnit = SourceUnit;\n/**\n * Парсинг исходника\n * @param source исходник\n */\n\nfunction parse(source) {\n  return new SourceUnit().parse(source);\n}\n\nexports.parse = parse;\n\n//# sourceURL=webpack:///./out/ts/vm/SourceUnit.js?");

/***/ })

/******/ });